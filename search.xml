<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git小技巧</title>
      <link href="/post/b120bc47.html"/>
      <url>/post/b120bc47.html</url>
      
        <content type="html"><![CDATA[<p>Q：本地分支develop不小心被删了，怎么办 ！！？<br>A：不要慌，使用 <code>git branch new_develop 5fs3424</code> 重新创建一个新分支，那個 <code>5fs3424</code>  是怎么来的。通常在删掉分支的时候，会有这样的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D develop</span><br><span class="line">Deleted branch develop (was 5fs3424).</span><br></pre></td></tr></table></figure><p>Q：A分支想要合并B分支的某个commit ？<br>A：在A分支上 <code>git cherry-pick 5fs3424</code>，<code>5fs3424</code>为B分支上commit值，当然也可以接多个～</p><p>Q：敲了一半代码， 要切另一个分支改紧急bug怎么办 ？<br>A：可以使用 <code>git stash</code> 将目前的进度保存，等切回分支后再使用 <code>git stash pop</code> 找回，<code>git stash list</code> 可以查看目前已保存的多个进度。<br>也可以使用 <code>git commit</code> 提交到本地仓库，等切回分支后再使用 <code>git reset</code> 把 commit 拆开来继续做。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊事件循环机制</title>
      <link href="/post/8f637f35.html"/>
      <url>/post/8f637f35.html</url>
      
        <content type="html"><![CDATA[<p>本篇主要讨论的是JavaScipt的事件循环机制（event loop），主要分为以下几个部分：</p><ol><li>为什么需要事件循环机制</li><li>事件循环机制的表现</li><li>有哪些使用场景</li><li>nodejs的事件循环（待补充）</li></ol><h2 id="为什么需要事件循环机制"><a href="#为什么需要事件循环机制" class="headerlink" title="为什么需要事件循环机制"></a>为什么需要事件循环机制</h2><p>众所周知，在浏览器中，<code>JavaScript</code> 是单线程的（原因在此处不做过多赘述），也就是说所有的事件都在一个线程中执行，这个线程负责处理：</p><ul><li>用户交互事件</li><li>DOM元素更新、绘制</li><li>执行js代码</li><li>…</li></ul><p>我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（<code>context</code>），又叫执行上下文。<br>这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 当一系列这样的方法被依次调用的时候，js 会将他们放入 <strong>执行栈</strong> 中依次执行（排队）。</p><p>如果某个任务执行时间过长，后面的任务则会一直处于等待状态，任务执行效率低且用户体验也不好，所以有了<code>异步任务</code> &amp; <code>事件循环机制</code>。</p><p>在 js 中，常用的异步编程方式有<strong>回调函数</strong>、<strong>Promise</strong> 和 <strong>async&#x2F;await</strong> 等。这些方式都可以让 js 代码异步执行，从而避免长时间阻塞 UI 线程。而异步任务的关键就在于任务队列，当异步任务开始执行的，会放入这个任务队列，执行完成之后，再从任务队列弹出，这个下面详细说明。</p><h2 id="事件循环机制的表现"><a href="#事件循环机制的表现" class="headerlink" title="事件循环机制的表现"></a>事件循环机制的表现</h2><p>js中任务主要分为：</p><ul><li>同步任务：马上可以拿到结果，耗时较短</li><li>异步任务：不知道什么时候可以拿到结果，时间未知</li></ul><p>当 <strong>执行栈</strong> 中出现了异步任务是一件很痛苦的事，所以我们可以不看让异步任务另外排队呢，这样也不影响同步任务的执行效率，是的，于是js中有了事件队列（Task Queue）的概念：<br>js引擎遇到一个异步任务后并不会一直等待其返回结果，而是会将这个任务挂起，继续执行执行栈中的其他任务。当一个异步任务返回结果后，js会将这个任务加入另外一个队列，我们称之为<strong>事件队列</strong>，事件队列中的任务不会马上执行，需要等到<strong>执行栈</strong>中的同步任务全部执行完成之后，主线程<strong>轮训</strong>查看事件队列中是否有任务需要执行，是的<strong>轮训</strong>，因为代码执行过程中会有新的 同步任务&#x2F;异步任务 排进执行栈，所以主线程会一直在<strong>执行栈</strong>跟<strong>任务队列</strong>中轮训，其实这大概就是<strong>事件循环</strong>的机制了，整体流程大概如下图所示。</p><p>如果在异步任务完成或放入执行栈执行，有新的同步任务产生，则会导致异步任务延迟执行。比如可能会导致 <code>setTimeout</code> 不准</p><p><img src="https://guozhigq.github.io/img/event_loop.png" alt="event loop"></p><p>但是，还没完。。。<br>异步任务分为很多种且执行优先级不一样，所以对于异步任务又做了细分：宏任务、微任务</p><ul><li>宏任务：Http请求、setTimeout、setInterval()</li><li>微任务：Promise.then、MutaionObserver()</li></ul><p>微任务一定优先于宏任务</p><p>上面提到过，异步任务返回结果后会被放入<strong>事件队列</strong>中。然而，为了细分<strong>宏任务</strong>跟<strong>微任务</strong>的执行顺序，会根据任务类型将任务放入对应的宏任务队列或微任务队列。<br>当在<strong>执行栈</strong>为空的时候，主线程会查看<strong>微任务队列</strong>是否有事件存在。</p><ul><li>不存在，会在<strong>宏任务队列</strong>中取出一个任务放入<strong>执行栈</strong></li><li>存在，执行<strong>微任务队列</strong>中的任务，直至为空，然后在<strong>宏任务队列</strong>中取出一个任务放入<strong>执行栈</strong><br>等待<strong>执行栈</strong>的任务完成&#x2F;清空后，再依次检查 <strong>微任务队列</strong>、<strong>宏任务队列</strong>等等<br>以上就是<code>JavaScript</code>的事件循环机制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout设置为0时也属于宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意：在每个循环的末尾，会进行一次dom的更新渲染，vue中$nextTick与此有异曲同工之处，或者说是借鉴了这里</p><h2 id="有哪些使用场景"><a href="#有哪些使用场景" class="headerlink" title="有哪些使用场景"></a>有哪些使用场景</h2><ul><li>使用 <code>setTimeout</code>对不重要的事件，同步任务异步化，避免主线程阻塞</li><li>$nextTick的实现：$nextTick内部实现优先级：微任务setImmediate、微任务MessageChannel、宏任务setTimeout、Promise.then</li><li>待补充</li></ul><h2 id="nodejs事件循环"><a href="#nodejs事件循环" class="headerlink" title="nodejs事件循环"></a>nodejs事件循环</h2><p>待补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="/post/2b2f44ba.html"/>
      <url>/post/2b2f44ba.html</url>
      
        <content type="html"><![CDATA[<p>自从 JavaScript 诞生以来，人们一直将它作为一种网页脚本语言，一般只用作表单校验跟页面特效，由于被仓促的创造出来，所以它自身的各种陷阱和缺点也被编程人员所诟病。随着 Web2.0 的流行，各种前端库和框架被开发出来，随后随着更多的用户需求在前端被实现，JavaScript 也从表单校验跃迁到应用开发的级别上。在这个过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。</p><span id="more"></span><p>随着业务发展，为了能够更好的组织业务逻辑，JavaScript 有了<strong>模块化</strong>的需求。</p><p>一般的，我们在 JavaScript 中通过 <strong>script</strong> 标签引入代码的方式来实现模块化，但这样往往缺乏组织能力跟约束能力，对于开发者而言需要人为的对代码进行约束，避免变量、函数冲突等问题。</p><br/><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><hr/><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><ul><li>将代码按照功能进行封装，遵循单一职责。</li><li>模块内部数据私有, 通过向外暴露的变量、方法与外部通信。</li></ul><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h3><ul><li>全局 function 模式，根据功能将模块封装成不同的全局函数。<!-- -   弊端：污染全局命名空间，容易造成命名冲突，模块之间的关系模糊 --></li><li>nameSpace 模式，对对象进行封装。减少全局变量，解决命名冲突。<!-- -   弊端：数据不安全，外部可以直接对模块内的数据进行修改 --></li><li>IIFE 立即执行函数，数据是私有的, 外部只能通过暴露的方法操作。<!-- -   弊端：无法处理模块相互依赖的场景 --></li></ul><br/><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><hr/><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>CommonJs 规范主要用于 Node.js，每一个文件就是一个模块，有自己的作用域，每个文件中的变量、函数、类都是私有的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>导出的是值的拷贝</li><li>独立作用域，不污染全局作用域</li><li>顺序加载</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>导出：使用 <font color=#2F74DC>module.export</font> 导出，也可以简写为 <font color=#2F74DC>exports</font>。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 <strong>module.exports</strong>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.export 导出</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">    <span class="attr">add</span>: add,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exports 导出</span></span><br><span class="line"><span class="keyword">export</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>导入：使用 <font color=#2F74DC>require</font> 同步加载模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&quot;./math&quot;</span>);</span><br><span class="line">math.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>模块重命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用新的求和方法 newAdd</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">add</span>: newAdd &#125; = <span class="built_in">require</span>(<span class="string">&quot;./math&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h4><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这部分跟 ES6 模块化有所不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">counter</span>: counter,</span><br><span class="line">    <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在执行 <strong>incCounter</strong> 前后，lib.js 中的 <strong>counter</strong> 始终为 3，可以得知 CommonJS 输出的是值的拷贝。</p><br/><h3 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>浏览器环境默认支持</li><li>输出的是值的引用</li><li>动态引用，不会缓存值</li><li>静态化，编译时就能确定模块间的依赖关系，以及输入输出的变量，可以 tree shaking</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>导出：使用 <font color=#2F74DC>export</font> 导出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; add, total &#125;;</span><br></pre></td></tr></table></figure><ul><li>导入：使用 <font color=#2F74DC>import</font> 导入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add, total &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>模块重命名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> newAdd <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="加载机制-1"><a href="#加载机制-1" class="headerlink" title="加载机制"></a>加载机制</h4><ul><li>模块加载方式取决于所处的环境，Node.js 环境中同步加载，浏览器端异步加载</li></ul><br/><p>但是但是，在日常开发中我们发现以<code>CommonJs</code>模式引入的插件也可以跑在浏览器中，这是为什呢？</p><p>概括的来说，<code>webpack</code>会根据webpack.config.js入口文件识别模块依赖，统一对模块进行分析，通过转换、编译，打包成最终的文件。最终文件中的模块实现是基于webpack自己实现的 <code>webpack_require</code>（es5代码），所以打包后的文件可以跑在浏览器上。即 <strong>webpack会对各种模块进行语法分析，并做转换编译</strong></p><p>来看看<code>webpack</code>对此做了些什么：</p><ul><li><p>简单的对webpack进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建一个EsModule格式的模块并导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// src/add</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; name &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;hello world,&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> name + a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&#x27;./add&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;求和&#x27;</span>, <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打包完成后的<code>bundle.js</code>文件输出如下:</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// modules是存放所有模块的数组，数组中每个元素存储&#123; 模块路径: 模块导出代码函数 &#125;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">modules</span>) &#123;</span><br><span class="line"><span class="comment">// 模块缓存作用，已加载的模块可以不用再重新读取，提升性能</span></span><br><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键函数，加载模块代码</span></span><br><span class="line"><span class="comment">// 形式有点像Node的CommonJS模块，但这里是可跑在浏览器上的es5代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">__webpack_require__</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line">  <span class="comment">// 缓存中存在则直接导出</span></span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].<span class="property">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则新建</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable language_">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    <span class="attr">i</span>: moduleId,</span><br><span class="line">    <span class="attr">l</span>: <span class="literal">false</span>, <span class="comment">// 标记是否已经加载</span></span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125; <span class="comment">// 初始模块为空</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把要加载的模块内容，挂载到module.exports上</span></span><br><span class="line">  modules[moduleId].<span class="title function_">call</span>(<span class="variable language_">module</span>.<span class="property">exports</span>, <span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require__);</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">l</span> = <span class="literal">true</span>; <span class="comment">// 标记为已加载</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回加载的模块，调用方直接调用即可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __webpack_require__对象下的r函数</span></span><br><span class="line"><span class="comment">// 在module.exports上定义__esModule为true，表明是一个模块对象</span></span><br><span class="line">__webpack_require__.<span class="property">r</span> = <span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动入口模块main.js</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(__webpack_require__.<span class="property">s</span> = <span class="string">&quot;./src/main.js&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">  <span class="comment">// add模块</span></span><br><span class="line">  <span class="string">&quot;./src/add.js&quot;</span>: (<span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;</span><br><span class="line">    <span class="comment">// 在module.exports上定义__esModule为true</span></span><br><span class="line">    __webpack_require__.<span class="title function_">r</span>(__webpack_exports__);</span><br><span class="line">    <span class="comment">// 直接把add模块内容，赋给module.exports.default对象上</span></span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; name &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;hello world,&#x27;</span>&#125;</span><br><span class="line">      <span class="keyword">return</span> name + a + b</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入口模块</span></span><br><span class="line">  <span class="string">&quot;./src/main.js&quot;</span>: (<span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;</span><br><span class="line">    __webpack_require__.<span class="title function_">r</span>(__webpack_exports__)</span><br><span class="line">    <span class="comment">// 拿到add模块的定义</span></span><br><span class="line">    <span class="comment">// _add__WEBPACK_IMPORTED_MODULE_0__ = module.exports，有点类似require</span></span><br><span class="line">    <span class="keyword">var</span> _add__WEBPACK_IMPORTED_MODULE_0__ = <span class="title function_">__webpack_require__</span>(<span class="string">&quot;./src/add.js&quot;</span>);</span><br><span class="line">    <span class="comment">// add模块内容: _add__WEBPACK_IMPORTED_MODULE_0__[&quot;default&quot;]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(_add__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>], <span class="title class_">Object</span>(_add__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>])(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，打包后的代码直接跑在浏览器中，是因为webpack通过__webpack_require__ 函数模拟了模块的加载，并使用<code>module.exports</code> 导出。</p>]]></content>
      
      
      <categories>
          
          <category> 拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Action 自动构建 Flutter Android Apk</title>
      <link href="/post/25ae93b9.html"/>
      <url>/post/25ae93b9.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这段时间用 Flutter 做了一个开源的项目 <a href="https://github.com/guozhigq/flutter_v2ex">VVEX</a>, 因为需要打包 apk，在此之前一直是手动 flutter build apk，再把文件上传到 release，每次发布新版本确实有点繁琐。趁着有空来使用 Github Action 做个持续化集成，自动打包 apk。</p><p><strong>最后完成的自动化构建脚本如下：</strong></p><p><strong>更新：</strong> 5月谷歌发布了Flutter stable 3.10.0 版本，可能会出现插件不兼容情况，需要将 yml 文件中flutter对应 <code>channel</code> 改为 <code>any</code>，<code>flutter-version</code>需要指定为某一版本，以确保打包环境正常。</p><p>为了方便阅读，部分 step 的 name 都使用了中文命名</p><span id="more"></span><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">build_apk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># action事件触发</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">    <span class="attr">push:</span></span><br><span class="line">        <span class="comment"># push tag时触发</span></span><br><span class="line">        <span class="attr">tag:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">v*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以有多个jobs</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="attr">build_apk:</span></span><br><span class="line">        <span class="comment"># 运行环境 ubuntu-latest window-latest mac-latest</span></span><br><span class="line">        <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每个jobs中可以有多个steps</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">代码迁出</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">构建Java环境</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">distribution:</span> <span class="string">&quot;zulu&quot;</span></span><br><span class="line">                  <span class="attr">java-version:</span> <span class="string">&quot;17&quot;</span></span><br><span class="line">                  <span class="attr">token:</span> <span class="string">$&#123;&#123;secrets.GIT_TOKEN&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查缓存</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">              <span class="attr">id:</span> <span class="string">cache-flutter</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">path:</span> <span class="string">/root/flutter-sdk</span> <span class="comment"># Flutter SDK 的路径</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-flutter-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/pubspec.lock&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装Flutter</span></span><br><span class="line">              <span class="attr">if:</span> <span class="string">steps.cache-flutter.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">subosito/flutter-action@v2</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">flutter-version:</span> <span class="number">3.7</span><span class="number">.7</span></span><br><span class="line">                  <span class="attr">channel:</span> <span class="string">any</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">下载项目依赖</span></span><br><span class="line">              <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">pub</span> <span class="string">get</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">解码生成</span> <span class="string">jks</span></span><br><span class="line">              <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$KEYSTORE_BASE64</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-di</span> <span class="string">&gt;</span> <span class="string">android/app/vvex.jks</span></span><br><span class="line">              <span class="attr">env:</span></span><br><span class="line">                  <span class="attr">KEYSTORE_BASE64:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEYSTORE_BASE64</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span></span><br><span class="line">              <span class="comment"># 对应 android/app/build.gradle signingConfigs中的配置项</span></span><br><span class="line">              <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span> <span class="string">--release</span> <span class="string">--split-per-abi</span></span><br><span class="line">              <span class="attr">env:</span></span><br><span class="line">                  <span class="attr">KEYSTORE_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEYSTORE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">                  <span class="attr">KEY_ALIAS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_ALIAS</span> <span class="string">&#125;&#125;</span></span><br><span class="line">                  <span class="attr">KEY_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_PASSWORD&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">发布</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">ncipollo/release-action@v1</span></span><br><span class="line">              <span class="attr">with:</span></span><br><span class="line">                  <span class="attr">artifacts:</span> <span class="string">&quot;build/app/outputs/flutter-apk/app-*.apk&quot;</span></span><br><span class="line">                  <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GIT_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">                  <span class="attr">allowUpdates:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="在此处有两点需要特别注意一下："><a href="#在此处有两点需要特别注意一下：" class="headerlink" title="在此处有两点需要特别注意一下："></a>在此处有两点需要特别注意一下：</h3><ul><li>无签名打包</li><li>带签名打包</li></ul></br><h4 id="无签名打包"><a href="#无签名打包" class="headerlink" title="无签名打包"></a>无签名打包</h4><p>在使用 GitHub 完成自动化构建之前，一直使用的是无签名打包，很简单，不需要额外配置什么<br>无签名打包的脚本需要去掉上面的这部分内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">解码生成</span> <span class="string">jks</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$KEYSTORE_BASE64</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-di</span> <span class="string">&gt;</span> <span class="string">android/app/vvex.jks</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">      <span class="attr">KEYSTORE_BASE64:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEYSTORE_BASE64</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span> <span class="string">--release</span> <span class="string">--split-per-abi</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">        <span class="attr">KEYSTORE_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEYSTORE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">KEY_ALIAS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_ALIAS</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">KEY_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_PASSWORD&#125;&#125;</span></span><br></pre></td></tr></table></figure></br><p>以下部分需要保留</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span></span><br><span class="line">   <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span> <span class="string">--release</span> <span class="string">--split-per-abi</span></span><br></pre></td></tr></table></figure></br><h4 id="带签名打包"><a href="#带签名打包" class="headerlink" title="带签名打包"></a>带签名打包</h4><p><strong>签名文件 xxx.js 跟 xxx.properties 文件不要提交至公共仓库</strong><br>主要分下面几步</p><ul><li>生成签名 jks 文件：比如 <strong>vvex.jks</strong></li><li>创建 <strong>key.properties</strong> 文件</li><li>修改 <strong>build.gradle</strong> 文件</li><li>Github 配置 <strong>action secrets</strong></li></ul></br><h5 id="生成签名文件"><a href="#生成签名文件" class="headerlink" title="生成签名文件"></a>生成签名文件</h5><p>此处及以下以 VVEX 举例 Mac 环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移动至桌面</span></span><br><span class="line"><span class="built_in">cd</span> desktop</span><br><span class="line"><span class="comment"># 创建 jks文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> jks</span><br><span class="line"><span class="built_in">cd</span> jks</span><br><span class="line"><span class="comment"># 生成jks</span></span><br><span class="line">keytool -genkeypair -<span class="built_in">alias</span> vvex -keyalg RSA -keysize 2048 -keypass password -keystore vvex.jks -storepass password -validity 10000</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><strong>-alias vvex</strong> 此处的 <strong>vvex</strong> 可以自定义修改为任意</li><li><strong>-keystore vvex.jks</strong> 此处的 <strong>vvex</strong> 可以自定义修改为任，建议与别名相同</li><li>建议以上 vvex 为相同内容</li><li><strong>-keypass password</strong> 此处的 <strong>password</strong> 设置密钥密码</li><li><strong>-storepass password</strong> 此处的 <strong>password</strong> 设置密钥库密码</li><li>建议以上 password 为相同内容</li></ul><p>vvex.jks 文件生成完成后，复制至 android&#x2F;app 目录下</p><p>至此，第一步完成</p></br><h5 id="创建-key-properties-文件"><a href="#创建-key-properties-文件" class="headerlink" title="创建 key.properties 文件"></a>创建 key.properties 文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -storepass password 处的password</span></span><br><span class="line">storePassword = password</span><br><span class="line"><span class="comment"># -keypass password 处的password</span></span><br><span class="line">keyPassword = password</span><br><span class="line"><span class="comment"># 别名</span></span><br><span class="line">keyAlias = vvex</span><br><span class="line"><span class="comment"># 此处注意 直接写xxxx.jks就可以，不需要写其他路径</span></span><br><span class="line">storeFile = vvex.jks</span><br></pre></td></tr></table></figure><p>key.properties 文件生成完成后，复制至 android 目录下</p><p>至此，第一步完成</p></br><h5 id="修改-build-gradle-文件"><a href="#修改-build-gradle-文件" class="headerlink" title="修改 build.gradle 文件"></a>修改 build.gradle 文件</h5><p><strong>android&#x2F;app</strong> 目录下的 <strong>build.gradle</strong> 文件增加以下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  引用 key.properties 文件</span></span><br><span class="line">def keystorePropertiesFile = rootProject.<span class="title function_">file</span>(<span class="string">&#x27;key.properties&#x27;</span>)</span><br><span class="line">def keystoreProperties = <span class="keyword">new</span> <span class="title class_">Properties</span>()</span><br><span class="line"><span class="keyword">if</span> (keystorePropertiesFile.<span class="title function_">exists</span>()) &#123;</span><br><span class="line">    keystoreProperties.<span class="title function_">load</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(keystorePropertiesFile))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def _storeFile = <span class="title function_">file</span>(<span class="title class_">System</span>.<span class="title function_">getenv</span>(<span class="string">&quot;KEYSTORE&quot;</span>) ?: keystoreProperties[<span class="string">&quot;storeFile&quot;</span>] ?: <span class="string">&quot;vvex.jks&quot;</span>)</span><br><span class="line">def _storePassword = <span class="title class_">System</span>.<span class="title function_">getenv</span>(<span class="string">&quot;KEYSTORE_PASSWORD&quot;</span>) ?: keystoreProperties[<span class="string">&quot;storePassword&quot;</span>]</span><br><span class="line">def _keyAlias = <span class="title class_">System</span>.<span class="title function_">getenv</span>(<span class="string">&quot;KEY_ALIAS&quot;</span>) ?: keystoreProperties[<span class="string">&quot;keyAlias&quot;</span>]</span><br><span class="line">def _keyPassword = <span class="title class_">System</span>.<span class="title function_">getenv</span>(<span class="string">&quot;KEY_PASSWORD&quot;</span>) ?: keystoreProperties[<span class="string">&quot;keyPassword&quot;</span>]</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  signingConfigs &#123;</span><br><span class="line">    <span class="comment">// 添加签名配置</span></span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="comment">// 配置密钥库文件的位置、别名、密码等信息</span></span><br><span class="line">        storeFile _storeFile</span><br><span class="line">        storePassword _storePassword</span><br><span class="line">        keyAlias _keyAlias</span><br><span class="line">        keyPassword _keyPassword</span><br><span class="line">        v1SigningEnabled <span class="literal">true</span></span><br><span class="line">        v2SigningEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      signingConfig signingConfigs.<span class="property">release</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 大写字符 <strong>KEYSTORE_PASSWORD</strong>、<strong>KEY_ALIAS</strong>、<strong>KEY_PASSWORD</strong> 在 github 设置<strong>secrets</strong>时会用到</p><h5 id="Github-配置-action-secrets"><a href="#Github-配置-action-secrets" class="headerlink" title="Github 配置 action secrets"></a>Github 配置 action secrets</h5><ul><li>打开远程仓库的设置页面（用户名及仓库名记得替换为自己的）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/guozhigq/flutter_test/settings/secrets/actions</span><br></pre></td></tr></table></figure></li><li>点击右上方 【New repository secret】</li><li>依次创建 Actions secrets</li></ul><table><thead><tr><th>name</th><th>Secret</th><th>说明</th></tr></thead><tbody><tr><td>KEYSTORE_BASE64</td><td>base64</td><td>vvex.jks base64 编码</td></tr><tr><td>KEY_ALIAS</td><td>vvex</td><td><strong>-alias vvex</strong>处的 vvex</td></tr><tr><td>KEY_PASSWORD</td><td>password</td><td><strong>-keypass password</strong>处的 password</td></tr><tr><td>KEYSTORE_PASSWORD</td><td>password</td><td><strong>-storepass password</strong>处的 password</td></tr><tr><td>KEY_PROPERTIES</td><td>base64</td><td>key.properties base64 编码</td></tr><tr><td>GIT_TOKEN</td><td>字符串</td><td>github 设置中生成</td></tr></tbody></table></br><p><strong>如何对 vvex.jks、key.properties 进行 base64 编码</strong><br>方便起见，将 key.properties 复制到 desktop&#x2F;jks 文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成base64并复制到了粘贴板，直接到github复制即可</span></span><br><span class="line"><span class="built_in">base64</span> vvex.jks | pbcopy</span><br><span class="line"><span class="built_in">base64</span> key.properties | pbcopy</span><br></pre></td></tr></table></figure></br><p>如何生成 <strong>GIT_TOKEN</strong><br><a href="https://github.com/settings/tokens">打开 tokens 设置页面</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床加载失败？我们来看看发生了什么</title>
      <link href="/post/6bb61c1a.html"/>
      <url>/post/6bb61c1a.html</url>
      
        <content type="html"><![CDATA[<p>最近在学习 fluuter，所以开发了一款应用，起名为：<a href="https://github.com/guozhigq/flutter_v2ex">VVEX</a>，数据都是通过模拟请求，解析 html 结构拿到的。</p><p>今天在手机上浏览主题时，发现在详情页会出现加载时白屏的情况，如下图。很明显可以判断是图片加载异常导致的问题。打开编辑器 🔨 ，复现一下问题，很明显我们图片资源出了点有问题</p><span id="more"></span><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flutter: https:<span class="comment">//tutu.to/ttt_tvI99C.png</span></span><br><span class="line">flutter: Exception: Invalid image data</span><br><span class="line">flutter: Exception: Invalid image data</span><br><span class="line">... ...</span><br><span class="line">...      inherit: <span class="keyword">false</span></span><br><span class="line">...      color: Color(<span class="number">0xff191c1b</span>)</span><br><span class="line">...      family: NotoSansSC</span><br><span class="line">...      size: <span class="number">14.0</span></span><br><span class="line">...      weight: <span class="number">400</span></span><br><span class="line">...      letterSpacing: <span class="number">0.3</span></span><br><span class="line">...      baseline: alphabetic</span><br><span class="line">...      height: <span class="number">1.4</span>x</span><br><span class="line">...      leadingDistribution: even</span><br><span class="line">...      decoration: Color(<span class="number">0xff191c1b</span>) TextDecoration.none</span><br><span class="line">...      <span class="string">&quot;load image failed, click to reload&quot;</span></span><br><span class="line">====================================================================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试在浏览器中打开，发现重定向到了 <a href="https://tutu.to/show/ttt_tvI99C-png">https://tutu.to/show/ttt_tvI99C-png</a>，这就值得怀疑了，是不是在 app 中使用 http get 获取图片资源时，发生了重定向直接返回了 html 结构，并非有效的 bytes 数据，导致图片加载失败呢？</p><hr/>我们先尝试在postman中模拟请求，图片没有正常显示，返回了html结构<p>同样的，我们在 app 中直接使用 http 请求图片，跟 postman 返回了同样的 html 结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[log] <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span> <span class="attr">class</span>=<span class="string">&quot;relative min-full&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;strict-origin-when-cross-origin&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">content</span>=<span class="string">&quot;Qc2IhKwxEALVm7hdNXnLl8uaSBkpStYXnTlSvkOI&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0.1;url=show/ttt_tvI99C-png&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">            <span class="attr">defer</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">&quot;https://s.urstudio.cn/pixel/YIavbDTc6LktjXg2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">referrerpolicy</span>=<span class="string">&quot;origin&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr/><p>于是我在浏览器中访问原主题，发现图片可以正常显示，通过查看 Dom，发现 <a href="https://tutu.to/ttt_tvI99C.png">图片链接</a> 也相同，另外在 image 标签上有额外两个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">referrerpolicy = <span class="string">&quot;no-referrer&quot;</span>;</span><br><span class="line">rel = <span class="string">&quot;noreferrer&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么，跟这两个属性有关吗？</p><h5 id="referrerpolicy"><a href="#referrerpolicy" class="headerlink" title="referrerpolicy"></a>referrerpolicy</h5><blockquote><p>这个属性定义了<img> 元素在获取资源时的引用方式。<br>属性有：</p></blockquote><ul><li>no-referrer：表示 HTTP 头部信息将不会发送 referrer</li><li>origin： referrer 只包含策略、主机名、端口等页面源的信息</li><li>unsafe-url： 这意味着引用者将包括源站和路径（但不包括片段、密码或用户名）。这种情况是不安全的，因为它可能会泄漏路径信息，这些信息已被使用 TLS 隐藏到第三方。</li></ul><h5 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h5><p>另外 <code>Referer</code>单独讲</p><blockquote><p>Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。</p></blockquote><p>mark 此处，我们先继续往下看。</p><p>查看网络请求，发现图片资源的请求响应中并没有返回类似于 redirect 重定向的内容</p><p>复制 cURL 到 postman 模拟请求，图片可以正常返回，找到请求头中关键字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;sec-fetch-dest&#x27;</span> : image</span><br></pre></td></tr></table></figure><p>关于<code>Sec-Fetch-Dest</code>在MDN上的说明</p><blockquote><p>Sec-Fetch-Dest Fetch 元数据请求标头指示请求的目标，即数据的来源以及如何使用这些获取到的数据。<br>这允许服务器根据请求是否采用了适当的使用方式来确定是否为请求提供服务。例如，具有 audio 目标的请求应请求音频数据，而不是其他类型的资源（例如，包含敏感用户信息的文档）。</p></blockquote><p>在此处我们使用指定 sec-fetch-dest 的类型为image，成功解决。<br></br><br>那么 <code>Sec-Fetch-Dest</code> 又是什么东东呢？<br>简单来说，就是网络请求的元数据描述，服务端根据这些补充数据进行细粒度的控制响应，换句话说，服务端可以精确判断请求的合法性，杜绝非法请求和攻击，提高web服务的安全性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 本地持久化与缓存</title>
      <link href="/post/a690fcba.html"/>
      <url>/post/a690fcba.html</url>
      
        <content type="html"><![CDATA[<h3 id="Flutter-本地持久化与缓存"><a href="#Flutter-本地持久化与缓存" class="headerlink" title="Flutter 本地持久化与缓存"></a>Flutter 本地持久化与缓存</h3><p>需要使用的插件</p><ul><li>dart:io</li><li>path_provider</li></ul><p>涉及到缓存的插件</p><ul><li>dio_http_cache</li><li>get_storage</li><li>cached_network_image</li><li>cookJar 3.0.1</li></ul><p>dio_http_cache</p><ul><li>0.3.0</li><li>缓存目录 【可使用 path_provider 提供的 getApplicationDocumentsDirectory 方法获取到】<ul><li>ios 端 &#x2F;Users&#x2F;user&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;A5F2542D-A814-4A70-8386-71D0094A2BFD&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;F9FF16B2-48DB-4003-82F1-35AAA41DC64F&#x2F;Documents</li></ul></li></ul><p>get_storage</p><ul><li>2.0.3</li><li>存储登录状态、用户信息、应用主题、各配置项开关</li><li>缓存目录 【可使用 path_provider 提供的 getApplicationDocumentsDirectory 方法获取到】<ul><li>ios 端 &#x2F;Users&#x2F;user&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;A5F2542D-A814-4A70-8386-71D0094A2BFD&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;F9FF16B2-48DB-4003-82F1-35AAA41DC64F&#x2F;Documents</li></ul></li></ul><p>cached_network_image</p><ul><li>3.2.3</li><li>缓存目录<ul><li>ios 端 &#x2F;Users&#x2F;user&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;A5F2542D-A814-4A70-8386-71D0094A2BFD&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;F9FF16B2-48DB-4003-82F1-35AAA41DC64F&#x2F;Library&#x2F;Caches&#x2F;libCachedImageData</li></ul></li></ul><p>需要删除的缓存</p><ul><li>dio_http_cache &#x2F;Documents<ul><li>DioCacheManager(CacheConfig(baseUrl: baseUrl)).clearAll() 无效</li><li>需要手动删除 &#x2F;Documents&#x2F;</li></ul></li><li>cached_network_image &#x2F;Library&#x2F;Caches&#x2F;libCachedImageData</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie相关</title>
      <link href="/post/c1214502.html"/>
      <url>/post/c1214502.html</url>
      
        <content type="html"><![CDATA[<p>由于HTTP本身是无状态的，服务端无法区分谁是谁，所以有了cookie的概念。cookie的作用之一也就是区分用户，存储用户信息。</p><h3 id="cookie来去"><a href="#cookie来去" class="headerlink" title="cookie来去"></a>cookie来去</h3><p>cookie由服务端在响应头中通过set-cookie下发，浏览器接收到后，会自动将cookie中的字段保存起来，下次再发起请求时会自动在请求头中携带cookie</p><h3 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h3><ul><li>Domain：cookie的作用域，默认 <code>/</code>从A域名得到的cookie数值只有在请求A域名相关地址&#x2F;接口时才会携带。未设置时，与document.domain或者location.hostname相等。</li><li>path：可以共享 Cookie 的子目录，默认 <code>/</code> 根目录。</li><li>Expires&#x2F;Max-Age：有效期，不设置则关闭浏览器时自动清空cookie，Expires绝对时间，Max-Age相对时间（秒）。Max-Age优先级较高。</li><li>HttpOnly：为true时，不可被JavaScript获取到。</li><li>sameSite：限制第三方cookie的发送场景<ul><li>Strict：严格模式，完全禁止第三方cookie，跨站点时，任何情况下都不会发送 Cookie。</li><li>Lax：默认值。除了<code><a href="..."></a></code>、<code><link rel="prerender" href="..."/></code>、<code><form method="GET" action="..."></code> 均不发送第三方cookie。</li><li>None：跨站都发送。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/post/be7c79f7.html"/>
      <url>/post/be7c79f7.html</url>
      
        <content type="html"><![CDATA[<p>浏览器缓存主要分为强缓存、协商缓存，下面进行详细说明。</p><p>概括说明：当我们发起请求时，会先从浏览器缓存中查找是否有缓存数据，</p><ol><li>如果存在，直接返回数据。</li><li>如果不存在或者数据已失效&#x2F;过期，则从服务端获取。<br>即先进行<code>强缓存</code>判断，再与服务端进行<code>协商</code></li></ol><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>依赖字段： Expires、Cache-Control<br><code>Cache-Control</code> 优先于 <code>Expires</code></p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>来源：上一次响应过程中，服务器在响应头中返回的字段，过期时间，即资源的有效期，是绝对时间。<br>使用：浏览器在下次发起同一请求时，会通过Expries来判断该请求在本地的缓存是否过期，如果有效则直接读取，否则进行后续逻辑<br>弊端：客户端与服务端时间不一致，倒是命中不准确</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>来源：来源：上一次响应过程中，服务器在响应头中返回的字段。<br>常见属性：</p><ul><li>max-age：资源有效期，为相对时间，以秒为单位。比如 <code>max-age = 3600</code> 表示资源将在1小时后过期，浏览器在该时间段内直接使用本地缓存，不发起网络请求。</li><li>no-cache：客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</li><li>no-store：关闭缓存，即每次请求都不进行缓存是否有效的判断，直接向服务端发起请求。</li><li>public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）</li><li>private：表明响应只能被单个用户缓存，不能作为共享缓存</li><li>must-revalidate：一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</li><li>max-age&#x3D;0, must-revalidate：同no-cache</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>如果本地没有缓存和缓存失效，则走协商缓存的逻辑，协商缓存必定会向服务端发起请求。</p><p>依赖字段：Last-Modified 和 If-Modified-Since、ETag 和 If-None-Match （成对出现），服务端响应字段与客户端请求字段相对应</p><h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><blockquote><p>Last-Modified 服务端响应时返回<br>If-Modified-Since 客户端请求时携带</p></blockquote><p>服务端在响应头中返回 <code>Last-Modified</code> 字段来表示资源的最后修改时间。当客户端发送请求时，在请求头中携带 <code>If-Modified-Since</code> 字段（值为上次获取资源时服务器返回 <code>Last-Modified</code>）。服务端接收到请求后，会将 <code>If-Modified-Since</code> 与服务端资源最后修改时间进行比较。如果资源未被修改，响应 <code>304 Not Modified</code>，告知客户端可以使用本地缓存。否则，响应 <code>200 OK</code>，返回最新的资源以及<code>Last-Modified</code>。</p><h4 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h4><blockquote><p>ETag 服务端响应时返回<br>If-None-Match 客户端请求时携带</p></blockquote><p>ETag是资源的唯一标识，可以是资源的哈希值、版本号等，随着资源内容生成。</p><p>服务端在响应头中返回 <code>ETag</code> 字段表示资源的唯一性，通常是一个唯一的字符串。当客户端发送请求时，在请求头中携带 <code>If-None-Match</code> 字段（值为上次获取资源时服务端返回 <code>ETag</code>）。服务端接收到请求后，会将 <code>If-None-Match</code> 与服务端资源最新资源的标识进行比较。如果标识符相同，响应 <code>304 Not Modified</code>，告知客户端可以使用本地缓存。否则，响应<code>200 OK</code>，返回最新的资源以及<code>ETag</code>。</p><p><img src="https://guozhigq.github.io/img/brower_cache.png" alt="brower cache"></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>强缓存不会发起请求；协商缓存至少发起一次请求</li><li>🎯命中强缓存，Http状态码为<code>灰色的200</code>；🎯命中协商缓存，Http状态码为<code>304</code></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>很明显，浏览器之所以设置缓存肯定是有一些作用的，那么都有哪些使用场景呢？</p><ul><li>减少页面加载时间<br>当我们每次进入页面时，都需要从服务端获取css或js文件，然后进行加载、渲染等等会耗费一定的时间，如果能够把公共部分或者没有更新的部分缓存到本地，就可以省去请求耗时</li><li>资源预加载：在进入某页面时，对于体积较大的网络资源提前加载&amp;缓存</li><li>待补充…</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HTTP</title>
      <link href="/post/843bb9f9.html"/>
      <url>/post/843bb9f9.html</url>
      
        <content type="html"><![CDATA[<p>HTTP 又称超文本传输协议，自从1991年发布初始版本0.9，现如今已经到了HTTP 3.0。在这里做个笔记，来记录一下HTTP的前世今生</p><h3 id="HTTP-0-9-x2F-1-0"><a href="#HTTP-0-9-x2F-1-0" class="headerlink" title="HTTP 0.9&#x2F;1.0"></a>HTTP 0.9&#x2F;1.0</h3><p>HTTP 0.9不支持请求头，只支持GET方法。<br>HTTP 1.0 在0.9的基础了，增加了一些变化：</p><ul><li><p>请求中加入的版本号，例如 <code>HTTP/1.0</code></p></li><li><p>增加了请求头&amp;响应头</p></li><li><p>增加了HTTP Status Code 当然，业务开发中，一般都返回200</p></li><li><p>增加了<code>Content-Type</code>，可以传输其他文件了</p></li><li><p>新增&lt; code&gt;Expires</code> 缓存机制</p><p>在HTTP 1.0版本中存在的问题</p><ul><li>每发起一个请求都需要新建一个TCP链接，而每次建立TCP链接都需要进行三次握手，会产生巨大开销。</li><li>串行请求：多个请求时需要等到上一个请求返回后才能继续后续请求，导致页面&#x2F;数据加载缓慢。</li><li>不支持断点续传。</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>千呼万唤始出来，HTTP 1.1主要解决了 1.0 的网络性能问题，并增加了一些特性：</p><ul><li>HTTP 长链接： 增加 <code>Keepalive</code> 实现TCP链接重用，减少TCP三次握手的开销。</li><li>管道传输：可以同时发送多个请求，避免请求端对头阻塞，减少整体响应时间。（对于非幂等的POST请求或者有依赖的请求不适用）</li><li>支持 <code>Chunked Responses</code> 响应数据分块</li><li>缓存机制：增加 <code>Cache Control</code> 缓存机制</li><li>补充协议头内容，Language、Encoding、Type等等</li><li>增加 <code>HOST</code>，可以用于服务端区分域名信息</li><li>增加 <code>OPTIONS</code> 方法，</li><li>新增了TLS协议</li></ul><p>在HTTP 1.1版本中存在的问题</p><ul><li>请求并行数量限制，一般限制6个。（精灵图的优化来源于此，减少请求数，提高页面加载速度）</li><li>主要以文本格式传输数据，传输成本较大。</li></ul></li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>同样的，HTTP2.0也解决了1.1的一些问题：</p><ul><li>二进制传输</li><li>并发请求：在一个TCP链接中可以并发多个HTTP请求。</li><li>多路复用：一个TCP连接中存在多个流，同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装</li><li>头部压缩：在网络请求中，请求头的内容一般大且重复，数据冗余很严重，HTTP2.0中通过HPAK算法，消除重复部分（客户端与服务端维护同一份字典，把头部跟数据分离，封装成头帧和数据帧，每次请求只发送索引号，以此来达到减少冗余，降低开销的目的）。</li><li>服务端推送：服务端主动推送数据至客户端</li></ul><p>在HTTP 2.0中存在的问题</p><ul><li>队头阻塞问题，一旦丢包就会触发重传机制（TCP问题），其他请求需要等待重传完成之后才能继续请求</li><li>建立链接时需要先进行TCP三次握手、在TLS三次握手</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h3><p>HTTP3.0使用了基于UDP的QUIC协议</p><ul><li>没有了TCP的三次握手，并且TLS版本升级为1.3，允许客户端无需等待TLS握手完成就开始发送数据，实现快速建立连接</li><li>增加了丢包重传机制</li><li>默认加密</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>关键词： SYN、syn、Seq、ACK、ack</p><p>假设我们有客户端A与服务端B<br>在进行HTTP请求时，TCP需要建立连接，分为三步：</p><ol><li>第一次握手，A向服务端发端报文 SYN&#x3D;1，Seq&#x3D;16位随机数，由B接收到A要建立连接的消息。其中SYN&#x3D;1表示向服务端确认。</li><li>第二次握手，B收到A的消息后，作出回应，向A发送ack number &#x3D; seq + 1，syn&#x3D;1，ack&#x3D;1，以及生成的seq，表示确认联机。</li><li>第三次握手，A收到B的消息。通过 <code>ack number</code> 判断来源正确，通过 <code>ack=1</code> 得知B的确认联机消息，继续向B发送 <code>ack number = seq + 1</code>，ack&#x3D;1，B通过同样的对比得知A的确认消息，连接建立成功。</li></ol><p>可以看出主要是通过关键字及值的判断来确定双方信息及接收能力。</p><h3 id="为什么三次"><a href="#为什么三次" class="headerlink" title="为什么三次"></a>为什么三次</h3><ol><li>确认双方收发消息的功能都正常</li><li>建立多次连接时，如果第一个连接的握手丢失&#x2F;延迟，后续B再收到时，以为要建立新的连接，导致B一直在等待A的响应。<blockquote><p>DDOS攻击<br>通过频繁的GET请求向服务端发起建立连接的信息，恶意消耗服务器性能</p></blockquote></li></ol><blockquote><p>慢速攻击<br>利用HTTP Keepalive特性，要求WebServer保持TVCP连接不断开，通过阶段行的请求使的TCP被占满而无法接收新的请求</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>同样的，假设我们有客户端A与服务端B<br>在进行HTTP请求完成之后，TCP需要断开连接，分为四步：</p><ol><li>第一次挥手，A向B发送请求，FIN&#x3D;1，Seq，告知B要断开连接了</li><li>第二次挥手，B收到A的请求，回应ACK&#x3D;1，ack，告知A已经收到断开请求</li><li>第三次挥手，B等待所以的请求处理完，发起第三次挥手，FIN-1，Seq随机数，告知A准备断开连接</li><li>A收到B断开连接的请求，向B表示确认，ACK&#x3D;1,Seq&#x3D;随机数，告诉B收到请求，至此断开连接</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree shaking是什么？</title>
      <link href="/post/f3aa05d6.html"/>
      <url>/post/f3aa05d6.html</url>
      
        <content type="html"><![CDATA[<p>一直以来都知道在 webpack 打包优化中，有 tree shaking（别名：树摇）这一项优化，却不知道它的工作机制和原理，趁着今天复习知识的空学习一下</p><span id="more"></span><h4 id="tree-shaking-是什么？"><a href="#tree-shaking-是什么？" class="headerlink" title="tree shaking 是什么？"></a>tree shaking 是什么？</h4><p><strong>tree shaking</strong>，别名：树摇，最早是由<strong>Rollup</strong>实现。根据字面意思我们可以把它理解成一种工具，可以“摇动”我们的 JS 文件，将其中用不到的代码“摇”掉，属于性能优化的一部分。具体到实际场景中来看，我们在 webpack 项目中，会有一个入口文件，会有很多的依赖模块挂载在 index.js 下，但是我们只会用到其中的一部分，造成内存空间浪费， tree shaking 就可以将无用的模块剔除掉，实现代码体积优化的效果。</p><h4 id="tree-shaking-的工作机制"><a href="#tree-shaking-的工作机制" class="headerlink" title="tree shaking 的工作机制"></a>tree shaking 的工作机制</h4><p>因为 tree shaking 只能在静态的 modules 下工作，所以直到 ES6 的 import 语法中才可以完美使用。</p><!-- 虽然tree shaking 的概念很早就被提了出来，但是真正被利用却是在最近几年，一切都是因为它依赖于ES6的模块特征。我们回顾一下ES6 module 的特点：+ 只能作为模块顶层语句出现+ import 的模块名只能是字符串常量+ import binding 是 immutable的 --><!-- ES6模块依赖关系是确定的，和运行时的状态无关，所以可以进行可靠的静态分析。而 ComminJS 以 require() 引入模块是动态的，无法在运行前确定实际运行中需要的模块。 --><h4 id="tree-shaking-的原理是什么？"><a href="#tree-shaking-的原理是什么？" class="headerlink" title="tree shaking 的原理是什么？"></a>tree shaking 的原理是什么？</h4><ul><li>ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li><li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack一二三讲</title>
      <link href="/post/d9987a00.html"/>
      <url>/post/d9987a00.html</url>
      
        <content type="html"><![CDATA[<h4 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h4><p>webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源</p><span id="more"></span><h4 id="webpack基本功能和工作原理"><a href="#webpack基本功能和工作原理" class="headerlink" title="webpack基本功能和工作原理"></a>webpack基本功能和工作原理</h4><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li><li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li><li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><h4 id="webpack构建过程"><a href="#webpack构建过程" class="headerlink" title="webpack构建过程"></a>webpack构建过程</h4><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h4 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h4><p><strong>Webpack</strong> 的热更新又称热替换（<strong>Hot Module Replacement</strong>），缩写为 <strong>HMR</strong>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。<br>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 <strong>chunk diff</strong> (<strong>chunk</strong> 需要更新的部分)，实际上 <strong>WDS</strong> 与浏览器之间维护了一个 <strong>Websocket</strong>，当本地资源发生变化时，<strong>WDS</strong> 会向浏览器推送更新，并带上构建时的 <strong>hash</strong>，让客户端与上一次资源进行对比。客户端对比出差异后会向 <strong>WDS</strong> 发起 <strong>Ajax</strong> 请求来获取更改内容(文件列表、<strong>hash</strong>)，这样客户端就可以再借助这些信息继续向 <strong>WDS</strong> 发起 <strong>jsonp</strong> 请求获取该chunk的增量更新。<br>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <strong>HotModulePlugin</strong> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<strong>react-hot-loader</strong> 和 <strong>vue-loader</strong> 都是借助这些 API 实现 HMR。</p><h4 id="如何优化-webpack-打包速度？"><a href="#如何优化-webpack-打包速度？" class="headerlink" title="如何优化 webpack 打包速度？"></a>如何优化 webpack 打包速度？</h4><ul><li>使用高版本的 webpack 和 Node.js</li><li>多进程&#x2F;多实例构建：开启 <strong>parallel</strong> 参数，使用多进程压缩</li><li>css压缩：借助 <strong>optimize-css-assets-webpack-plugin</strong> 插件，压缩引擎是 <strong>cssnano</strong></li><li>擦除无用的css：使用 <strong>PurgeCSS</strong> 来完成对无用 css 的擦除，它需要和 <strong>mini-css-extract-plugin</strong> 配合使用。</li><li>图片压缩：配置 <strong>image-webpack-loader</strong>、使用基于 Node 库的 <strong>imagemin</strong></li><li>利用缓存提升二次构建速度：<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li>Tree shaking (摇树)<ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul><li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li></ul></li></ul></li><li>合理使用 Ployfill<ul><li>采用 polyfill-service 只给用户返回需要的polyfill</li></ul></li></ul><h4 id="常用的Label有哪些？"><a href="#常用的Label有哪些？" class="headerlink" title="常用的Label有哪些？"></a>常用的Label有哪些？</h4><ul><li>raw-loader：加载文件原始内容（utf-8）</li><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li><li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>svg-inline-loader：将压缩后的 SVG 内容注入代码中</li><li>image-loader：加载并且压缩图片文件</li><li>json-loader 加载 JSON 文件（默认包含）</li><li>handlebars-loader: 将 Handlebars 模版编译成函数并返回</li><li>babel-loader：把 ES6 转换成 ES5</li><li>ts-loader: 将 TypeScript 转换成 JavaScript</li><li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li><li>sass-loader：将SCSS&#x2F;SASS代码转换成CSS</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li><li>tslint-loader：通过 TSLint检查 TypeScript 代码</li><li>mocha-loader：加载 Mocha 测试用例的代码</li><li>coverjs-loader：计算测试的覆盖率</li><li>vue-loader：加载 Vue.js 单文件组件</li><li>i18n-loader: 国际化</li><li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ul><h4 id="常用的Plugin有哪些？"><a href="#常用的Plugin有哪些？" class="headerlink" title="常用的Plugin有哪些？"></a>常用的Plugin有哪些？</h4><ul><li>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li>ignore-plugin：忽略部分文件</li><li>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</li><li>web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li><li>uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)</li><li>terser-webpack-plugin: 支持压缩 ES6 (Webpack4)</li><li>webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</li><li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</li><li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li><li>clean-webpack-plugin: 目录清理</li><li>ModuleConcatenationPlugin: 开启 Scope Hoisting</li><li>speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li><li>webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li></ul><h4 id="Loader和Plugin的区别？"><a href="#Loader和Plugin的区别？" class="headerlink" title="Loader和Plugin的区别？"></a>Loader和Plugin的区别？</h4><ul><li><p>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p></li><li><p>Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p></li><li><p>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p></li><li><p>Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p></li></ul><h4 id="如何实现一个Loader？"><a href="#如何实现一个Loader？" class="headerlink" title="如何实现一个Loader？"></a>如何实现一个Loader？</h4><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><ul><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw &#x3D; true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<ul><li>Npm link</li><li>ResolveLoader</li></ul></li></ul><h4 id="如何实现一个Plugin？"><a href="#如何实现一个Plugin？" class="headerlink" title="如何实现一个Plugin？"></a>如何实现一个Plugin？</h4><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><ul><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>找出合适的事件点去完成想要的功能<ul><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</li><li>watch-run 当依赖的文件发生变化时会触发</li></ul></li><li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li></ul><h4 id="Babel原理"><a href="#Babel原理" class="headerlink" title="Babel原理"></a>Babel原理</h4><p>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p><ul><li>解析：将代码转换成 AST 语法树<ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST</li><li>生成：以新的 AST 为基础生成代码</li></ul><h4 id="source-Map-是什么？"><a href="#source-Map-是什么？" class="headerlink" title="source Map 是什么？"></a>source Map 是什么？</h4><p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。<br>map文件只要不打开开发者工具，浏览器是不会加载的。<br>线上环境一般有三种处理方案：</p><p>hidden-source-map：借助第三方错误监控平台 Sentry 使用<br>nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高<br>sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p><p>注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。<br>「用可接受的服务器性能压力增加来换取更好的用户体验。」<br>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。<br>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><br/>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS常用的循环遍历</title>
      <link href="/post/5ef4056b.html"/>
      <url>/post/5ef4056b.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><h4 id="for-、forEach、for…of"><a href="#for-、forEach、for…of" class="headerlink" title="for 、forEach、for…of"></a>for 、forEach、for…of</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, , <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = list.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[i] === <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 1 2 3 4</span></span><br><span class="line">        <span class="comment">// continue; // 1 2 3 4 6 7 8 undefined 10 11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(list[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 1 2 3 4</span></span><br><span class="line">        <span class="comment">// continue; // 1 2 3 4 6 7 8 undefined 10 11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">5</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 0 1 2 3 5 6 7 9 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// 1 2 3 4 6 7 8 9 10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>小结</strong></p><ul><li>这三种循环都是从左到右遍历数组;</li><li><strong>forEach</strong> 无法跳出循环；<strong>for</strong> 和 <strong>for…of</strong> 可以使用 <strong>break</strong> 或者 <strong>countinue</strong> 跳出循环或中断循环;</li><li><strong>for…of</strong> 直接访问的是实际元素。<strong>for</strong> 遍历数组索引，<strong>forEach</strong> 回调函数参数更丰富，元素、索引、原数组都可以获取;</li><li><strong>for…of</strong> 与 <strong>for</strong> 如果数组中存在空元素，同样会执行;</li></ul><h4 id="some、every"><a href="#some、every" class="headerlink" title="some、every"></a>some、every</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;头部导航&quot;</span>, <span class="attr">backward</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;轮播&quot;</span>, <span class="attr">backward</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;页脚&quot;</span>, <span class="attr">backward</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> someBackward = list.<span class="title function_">some</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">backward</span>);</span><br><span class="line"><span class="comment">// someBackward: true</span></span><br><span class="line"><span class="keyword">const</span> everyNewest = list.<span class="title function_">every</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> !item.<span class="property">backward</span>);</span><br><span class="line"><span class="comment">// everyNewest: false</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>二者都是用来做数组条件判断的，都是返回一个布尔值;</li><li>二者都可以被中断;</li><li><strong>some</strong> 若某一元素满足条件，返回 true，循环中断；所有元素不满足条件，返回 false;</li><li><strong>every</strong> 若有一元素不满足条件，返回 false，循环中断；所有元素满足条件，返回 true;</li></ul><h4 id="filter、map"><a href="#filter、map" class="headerlink" title="filter、map"></a>filter、map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;头部导航&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;nav&quot;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    ,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;轮播&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;content&quot;</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;页脚&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;nav&quot;</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> resultList = list.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">type</span> === <span class="string">&quot;nav&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// resultList: [</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;头部导航&#x27;, type: &#x27;nav&#x27;, id: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;页脚&#x27;, type: &#x27;nav&#x27;, id: 3 &#125;,</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">id</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// newList: [1, empty, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list: [</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;头部导航&#x27;, type: &#x27;nav&#x27;, id: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   empty,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;轮播&#x27;, type: &#x27;content&#x27;, id: 2 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;页脚&#x27;, type: &#x27;nav&#x27;, id: 3 &#125;,</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>二者都是生成一个新数组，都不会改变原数组（不包括遍历对象数组是，在回调函数中操作元素对象）;</li><li>二者都会跳过空元素;</li><li><strong>map</strong> 会将回调函数的返回值组成一个新数组，数组长度与原数组一致;</li><li><strong>filter</strong> 会将符合回调函数条件的元素组成一个新数组，数组长度与原数组不同;</li><li><strong>map</strong> 生成的新数组元素是可自定义;</li><li><strong>filter</strong> 生成的新数组元素不可自定义，与对应原数组元素一致;</li></ul><h4 id="find、findIndex"><a href="#find、findIndex" class="headerlink" title="find、findIndex"></a>find、findIndex</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;头部导航&quot;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;轮播&quot;</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;页脚&quot;</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;页脚&quot;</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = list.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === <span class="number">3</span>);</span><br><span class="line"><span class="comment">// result: &#123; name: &#x27;页脚&#x27;, id: 3 &#125;</span></span><br><span class="line">result.<span class="property">name</span> = <span class="string">&quot;底部导航&quot;</span>;</span><br><span class="line"><span class="comment">// list: [</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;头部导航&#x27;, id: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;轮播&#x27;, id: 2 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;底部导航&#x27;, id: 3 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: &#x27;页脚&#x27;, id: 3 &#125;,</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = list.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === <span class="number">3</span>);</span><br><span class="line"><span class="comment">// index: 2</span></span><br><span class="line">list[index].<span class="property">name</span>; <span class="comment">// &#x27;底部导航&#x27;;</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>二者都是用来查找数组元素;</li><li><strong>find</strong> 方法返回数组中满足 callback 函数的第一个元素的值。如果不存在返回 undefined;</li><li><strong>findIndex</strong> 它返回数组中找到的元素的索引，而不是其值，如果不存在返回 -1;</li></ul><h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fun</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">2</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="string">&quot;:&quot;</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1: b</span></span><br><span class="line"><span class="comment">// 2: a</span></span><br><span class="line"><span class="comment">// fun : () =&gt; &#123;&#125; Object 原型链上扩展的方法也被遍历出来for (const i in obj) &#123;  if (Object.prototype.hasOwnProperty.call(obj, i)) &#123;      console.log(i, &#x27;:&#x27;, obj[i]);    &#125;&#125;</span></span><br><span class="line"><span class="comment">// name : a 不属于自身的属性将被 hasOwnProperty 过滤</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ul><li>使用 <strong>for in</strong> 循环时，要注意返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例。如果只需要获取对象实例中的属性，可以使用 <strong>hasOwnProperty</strong> 进行过滤;</li><li>使用时，要使用 <strong>(const x in a)</strong> 而不是 <strong>(x in a)</strong> ，后者将会创建一个全局变量;</li></ul><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h4><ul><li>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组;</li><li>该对象可以是 数组<strong>Array</strong>、对象<strong>Object</strong>、字符串<strong>String</strong>;</li><li>当该对象为 字符串<strong>String</strong> 时，在 ES5 里，它会抛出 TypeError。在 ES2015 中，非对象的参数将被强制转换为一个对象;</li></ul><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">7</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(an_obj));</span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性值组成的数组;</li><li>当 obj 的可以值为数字时，返回顺序按照数字大小从小到大返回</li><li>同上</li></ul><h4 id="Object-entrise"><a href="#Object-entrise" class="headerlink" title="Object.entrise"></a>Object.entrise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">0</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="number">2</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123; <span class="number">100</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">7</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(anObj)); <span class="comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">7</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h4><p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fun</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj));</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="面试考点"><a href="#面试考点" class="headerlink" title="面试考点"></a>面试考点</h4><ol><li>for 、for in 、for…of 、 forEach 的区别</li><li>Object.keys 、 Object.values</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序用户授权又双叒改了</title>
      <link href="/post/80bad882.html"/>
      <url>/post/80bad882.html</url>
      
        <content type="html"><![CDATA[<p>为了优化用户体验，小程序平台又双叒改了，此次改动又涉及到哪些api呢？</p><span id="more"></span><h4 id="让我们看看这次又做了哪些更改"><a href="#让我们看看这次又做了哪些更改" class="headerlink" title="让我们看看这次又做了哪些更改"></a>让我们看看这次又做了哪些更改</h4><p>早在去年2月份，小程序社区里就发布相关公告: <a href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801">《小程序登录、用户信息相关接口调整说明》</a><br>大致内容总结如下：</p><ol><li>增加通过wx.login接口获取的登录凭证可直接换取unionID: <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session说明文档</a> <!-- 需要注意的是: 早在[2018年官方公告](https://developers.weixin.qq.com/community/develop/doc/000c2424654c40bd9c960e71e5b009?highline=getUserInfo)中就已经有了以下说明：  > 若用户满足一定条件，则可以用wx.login 获取到的code直接换到unionId --></li><li>原<code>&lt;button open-type=&quot;getUserInfo&quot;/&gt;</code>获取用户真实个人信息的能力取消，返回匿名信息。获取openID与unionID能力不做调整。<!-- 需要注意的是: 早在[2018年官方公告](https://developers.weixin.qq.com/community/develop/doc/000c2424654c40bd9c960e71e5b009?highline=getUserInfo)中就已经有了以下说明：  > 若用户满足一定条件，则可以用wx.login 获取到的code直接换到unionId --></li><li>新增getUserProfile接口，<code>&lt;button bindtap=&quot;getUserProfile&quot;&gt;&lt;/button&gt;</code>触发，可获取用户信息（头像、昵称、性别），用户加密数据，每次触发都会弹框。</li></ol><font size=2>需要注意的是：截止2021.04.09日，[wx.getUserProfile](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html) 在开发者工具调试中，基础库`2.15.0`及以下版本只返回用户信息，在基础库`2.16.0`版本增加返回`encryptedData`等用户加密数据，所以开发者一定要记得将基础库版本设置为2.16.0</font><h4 id="getUserProfile使用"><a href="#getUserProfile使用" class="headerlink" title="getUserProfile使用"></a>getUserProfile使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wxml 方法名称随意，一定要用button按钮触发</span></span><br><span class="line">&lt;button bindtap=<span class="string">&quot;getUserProfile&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="title function_">getUserProfile</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">getUserProfile</span>(&#123;</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span></span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">userInfo</span>: res.<span class="property">userInfo</span> <span class="comment">// 用户信息</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="兼容实现"><a href="#兼容实现" class="headerlink" title="兼容实现"></a>兼容实现</h4><p>通过上面的说明，我们可以总结以下： <code>wx.login + wx.getUserProfile == wx.getUserInfo</code><br>由于用户微信版本不一致，低版本的微信也不支持wx.getUserProfile（7.0.9以上支持），所以我们需要针对这种情况做出兼容处理，通过判断 wx.getUserProfile 是否存在来决定采用哪种授权方案<br><font size=2>wxml代码如下</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;view class=&quot;userinfo&quot;&gt;</span><br><span class="line">    &lt;block wx:if=&quot;&#123;&#123;!hasUserInfo&#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;button wx:if=&quot;&#123;&#123;canIUseGetUserProfile&#125;&#125;&quot; bindtap=&quot;getUserProfile&quot;&gt; 获取头像昵称 &lt;/button&gt;</span><br><span class="line">      &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">    &lt;block wx:else&gt;</span><br><span class="line">      &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt;</span><br><span class="line">      &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">    &lt;/block&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p><font size=2>js代码如下</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: false,</span><br><span class="line">    canIUseGetUserProfile: false,</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    if (wx.getUserProfile) &#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        canIUseGetUserProfile: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserProfile(e) &#123;</span><br><span class="line">    // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span><br><span class="line">    // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      desc: &#x27;用于完善会员资料&#x27;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span><br><span class="line">      success: (res) =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: true</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo(e) &#123;</span><br><span class="line">    // 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于用户头像、昵称等信息，可以按照下列方式进行处理</p><ol><li>前端调用wx.getUserProfile后，将用户信息缓存在本地</li><li>前端调用wx.getUserProfile后，将用户信息发送给后端，与用户信息绑定在一起<br><font size="2">注：在此处推荐方法2，这样一来用户在pc端打开小程序也可以直接从后端获取头像，而不需要再次授权</font></li></ol><h4 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h4><ul><li>按照目前官方的文档说明和公告，wx.getUserProfile和wx.getUserInfo的区别只在于弹框触发的频率，前者触发的时候每次都弹框，后者只会弹框一次，实在是不理解为什么要新增一个API而不是对现有的进行修改</li><li>官方说明在4.13号及之后提交的正式版小程序中，将支持wx.getUserProfile，wx.getUserInfo将返回匿名用户信息，但是，在4.2&#x2F;3号，很多线上的小程序wx.getUserInfo也返回了匿名消息，导致社区很多开发者反馈线上小程序无法获取用户信息。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用git进行代码回滚</title>
      <link href="/post/423abe9e.html"/>
      <url>/post/423abe9e.html</url>
      
        <content type="html"><![CDATA[<p>git回滚主要分为<strong>本地回滚</strong>、<strong>远程回滚</strong></p><p>在本地开发时，未 <code>git push</code> 之前我们都可以使用 <code>git reset</code> 进行回滚，当然，对于远程commit也是有效的，但不推荐，因为可能会冲掉其他人的 <code>commit</code> 记录，远程一般使用 <code>git revert</code> 进行回滚，下面就两种回滚方式进行具体说明。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>在介绍 <code>git reset</code> 之前，我们先了解一下git中的区域划分：</p><ul><li>工作区（WorkSpace）：开发的环境</li><li>暂存区（Stage&#x2F;Index）：使用 <code>git add</code> 相关命令将工作区的代码提交到暂存区</li><li>本地库（Local Repo）：使用 <code>git commit</code> 相关命令将工作区的代码提交到本地库</li><li>远程库（Remote）：使用 <code>git pu sh</code> 相关命令将本地库推送到远程<br>借用网上的一张图片进行说明<br><img src="https://guozhigq.github.io/img/git_workspace.png" alt="git workSpace"></li></ul><p>在使用 <code>git reset</code> 之前，我们需要清楚 <code>git reset</code> 等同于 <code>git reset --mixed</code> ，除此之外还有 <code>git reset --hard</code> 、<code>git reset --soft</code> </p><p><code>git reset</code> 是对HEAD指针的指向进行更改，历史记录中不会出现放弃的提交记录</p><ul><li><code>git reset --hard</code> 工作区、暂存区、本地仓库回滚到对应commit-id</li><li><code>git reset --mixed</code>  工作区代码不受影响，但是暂存区、本地仓库区的代码回滚到对应的commit-id</li><li><code>git reset --soft</code> 工作区和暂存区的代码不会受到影响，本地仓库区的代码回滚到对应的commit-id</li></ul><p>可以看出来，这三者对于git区域的影响范围依次递减</p><p>注意：<code>git reset</code> 回滚不会对远程分支产生影响，所以在回滚完成进行 <code>git push</code> 的时候，会提示本地分支比较旧，需要先使用 <code>git pull</code> 拉取远程分支，由于我们的目的是回滚，所以当然不需要再拉取远程分支了，此时，直接使用 <code>git push -f</code> 强制推送本地回滚后的代码至远程。</p><ul><li>git reset –hard <commit_id>  # 回到其中你想要的某个版</li><li>git reset –hard HEAD^  # 回到最新的一次提交</li><li>git reset HEAD^  # 此时代码保留，回到 git add 之前</li></ul><p>暂存区回滚时，我们也可以使用 <code>git reset</code></p><p>git reset 可以将暂存区的代码回滚到工作区。当我们使用 <code>git add</code> 相关命令将修改内容提交到暂存区，此时又反悔了，可以使用 <code>git reset HEAD . </code>或者 <code>git reset HEAD a.txt</code> 将代码回滚到未 <code>add</code> 之前。</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><code>git revert</code> 理解为回滚但由又不是回滚，等于是重新commit了一个修改，抵消掉 <code>git revert B</code> 中指定的分支。<br>比如：我们commit了三个版本A、B、C，由于某些原因需要撤销 <code>B</code> 保留<code>C</code> 的更改，这个时候就可以用 <code>git revert B</code> 命令来反做 <code>B</code> ，生成 <strong>新的版本</strong>  <code>D</code> ，版本 <code>D</code> 中保留了 <code>C</code> 的代码， <code>B</code> 的修改被重置。</p><h4 id="其他的回滚方式"><a href="#其他的回滚方式" class="headerlink" title="其他的回滚方式"></a>其他的回滚方式</h4><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>工作区回滚，使用 <code>git checkout</code></p><p>没错 git checkout 也可以回滚代码（或者叫“舍弃”）</p><ul><li>git checkout – a.txt   # 丢弃某个文件，或者</li><li>git checkout – .       # 丢弃全部<br>如果我们对代码进行了一些修改，增、删、改，此时又不想要了，可以使用 <code>git checkout -- .</code></li></ul></br><p>当然，还是推荐使用图形化工具，更顺手，而且不容易出错。<br>回滚远程仓库前记得提前通知团队其他成员！！！</p><!-- 通过git checkout <commit-id> 切换HEAD指向，查看之前提交的更改（只读状态），通过git checkout main/master切换回正在进行的修改 -->]]></content>
      
      
      <categories>
          
          <category> 效率开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git代码规范</title>
      <link href="/post/e75acacf.html"/>
      <url>/post/e75acacf.html</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。但是在团队开发中，很多不规范的使用，使得 Gitf 分支混乱，代码冲突难以解决，因此我们需要对 Git 提交规范做一些了解。</p><span id="more"></span><h5 id="在多人团队协作中，我们需要对项目代码进行共同对开发管理，在这一过程中，有很多规范需要我们严格执行："><a href="#在多人团队协作中，我们需要对项目代码进行共同对开发管理，在这一过程中，有很多规范需要我们严格执行：" class="headerlink" title="在多人团队协作中，我们需要对项目代码进行共同对开发管理，在这一过程中，有很多规范需要我们严格执行："></a>在多人团队协作中，我们需要对项目代码进行共同对开发管理，在这一过程中，有很多规范需要我们严格执行：</h5><ul><li>拉取最新的 develop 分支到本地</li><li>基于最新的 develop 分支新建你自己的本地分支</li><li>修改代码后，进行 commit 和 push</li><li>切换到 develop 分支并拉取最新的 develop 分支到本地分支</li><li>切换会你自己的本地分支，然后执行命令 git rebase develop 将你的分支变更到最新的 develop 分支</li><li>执行 git push -f 强行推送你变更后的分支</li><li>在 Github 上新建 Pull Request</li></ul><h3 id="commit规范"><a href="#commit规范" class="headerlink" title="commit规范"></a>commit规范</h3><p>Commit 规范采用常用的 Angular 团队所使用的规范，具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;&lt;scope&gt;: &lt;subject&gt;</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><h4 id="type规则（必填）"><a href="#type规则（必填）" class="headerlink" title="type规则（必填）"></a>type规则（必填）</h4><p>type 代表本次commit 的类型，有且仅有如下几种：</p><ul><li><strong>feat</strong> - 功能性更新</li><li><strong>fix</strong> - bug修复</li><li><strong>style</strong> - 改变代码格式（如删除空行、格式化代码、去除不必要的分号等等）</li><li><strong>refactor</strong> - 既不是功能更新也不是 bug 修复的更改（建议对代码进行重构的时候使用）</li><li><strong>perf</strong> - 代码改变提高了性能</li><li><strong>test</strong> - 添加测试用例或者修改测试用例</li><li><strong>build</strong> - 由打包工具造成的改变（如gulp、webpack编译文件）</li><li><strong>chore</strong> - 既不是源码的修改，也不是测试用例的修改（修改项目相关配置时可以使用）</li><li><strong>revert</strong> - 撤销之前的提交</li></ul><h4 id="scope-规则（必填）"><a href="#scope-规则（必填）" class="headerlink" title="scope 规则（必填）"></a>scope 规则（必填）</h4><p>scope 代表本次 commit 的影响范围，暂定规则如下：</p><ul><li>本次 commit 修改的组件</li><li>本次 commit 修改的文件</li><li>本次 commit 修改的文件夹</li></ul><blockquote><p>注意：</p><ul><li>选取时从上往下匹配</li><li>组件名称应使用大写字字母开头，多个单词每个单词都以大写开头</li><li>文件名应包含完整后缀，如 index.js、.eslintrc.json</li></ul></blockquote><h4 id="subject-规则（必填）"><a href="#subject-规则（必填）" class="headerlink" title="subject 规则（必填）"></a>subject 规则（必填）</h4><p>用一句简短的话描述本次修改的内容，<strong>不要超过30个汉字，以动词开头</strong></p><p>建议选用如下动词：</p><ul><li>新增（组件、属性、事件、API）</li><li>删除</li><li>修正</li><li>修复</li><li>修改</li></ul><p>正确示例：</p><ul><li>新增 Collapse 组件</li><li>新增 top 属性</li><li>删除 color 属性</li><li>修复 direction 属性不生效的问题</li><li>修正 column 属性拼写</li></ul><blockquote><p>注意：</p><ul><li>subject 应该仔细斟酌，fix 和 feat 类型的 commit 的 subject 将会出现在更新日志中，</li><li>所以书写时应考虑这句话出现在更新日志中是否合适</li><li>subject 中不要包含组件名或者文件名，因为 scope 中已有对应名称</li></ul></blockquote><h4 id="body-规则（选填）"><a href="#body-规则（选填）" class="headerlink" title="body 规则（选填）"></a>body 规则（选填）</h4><p>如果 subject 无法对本次 commit 进行清楚的阐释，则在 body 中进行补充说明。</p><p>建议填写以下内容：</p><ul><li>为什么进行本次修改</li><li>本次修改了哪些内容</li><li>修改后的影响有哪些</li></ul><blockquote><p>body 需要注意换行问题，不要写在一行不换行，建议在50个字以内进行断句换行。</p></blockquote><h4 id="footer-规则（选填）"><a href="#footer-规则（选填）" class="headerlink" title="footer 规则（选填）"></a>footer 规则（选填）</h4><p>footer 中只填写两种内容：</p><ul><li><p>这次 commit 和某个 issue 相关联，提交后能关闭该 issue，则填写：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close #<span class="number">748</span></span><br></pre></td></tr></table></figure><p>或者</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix #<span class="number">745</span></span><br></pre></td></tr></table></figure></li><li><p>这次commit有不兼容上个版本的代码，则以 BREAKING CHANGE: 开头填写不兼容信息，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BREAKING</span> <span class="attr">CHANGE</span>: <span class="title class_">Message</span>组件top属性单位由px改为rpx</span><br></pre></td></tr></table></figure><h4 id="Commit-示例"><a href="#Commit-示例" class="headerlink" title="Commit 示例"></a>Commit 示例</h4><p>一个完整闺房且正确的 Commit 示例如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fix</span>(<span class="title class_">NoticeBar</span>)：修改top属性单位为rpx</span><br><span class="line"></span><br><span class="line"><span class="title class_">NoticeBar</span>组件的top属性单位之前为px，会出现无法自适应的问题。</span><br><span class="line">更改为rpx后可对屏幕进行自适应。</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">BREAKING</span> <span class="attr">CHANGE</span>: <span class="title class_">Notice</span>-<span class="title class_">Bar</span>组件top属性单位由px改为rpx</span><br><span class="line"></span><br><span class="line"><span class="title class_">Close</span> #<span class="number">745</span></span><br></pre></td></tr></table></figure><p>推荐使用 commit 规范信息生成插件</p><blockquote><p>推荐 commit 规范信息生成插件</p><ul><li>WebStorm - Git Commit Template</li><li>Vs Code - Commit Tagger</li></ul></blockquote><h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><ol><li>subject 描述中出现组件名称 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">feat</span>(<span class="title class_">Button</span>): <span class="title class_">Button</span> 组件新增 size 属性</span><br></pre></td></tr></table></figure> 因type（括号中的内容）已经指定了组件，所以 subject 描述信息中无需再指明组件</li><li>单词未添加空格 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">feat</span>(<span class="title class_">Button</span>): 新增size属性</span><br></pre></td></tr></table></figure></li><li>feat、fix 类型需要慎重使用 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">feat</span>(<span class="title class_">Card</span>): 更新 validator 校验器校验规则</span><br></pre></td></tr></table></figure> 因为 feat 和 fix 类型的 commit 信息会出现在 changelog 中，所以要保证这条信息是面向用户的。如上例所示，因为 validator 仅是我们自己内部使用，并不面向用户，所以用户并不关心这个校验器的新增功能。建议使用 chore 代替此处的 feat（chore 的意思是琐碎的事务）</li></ol><h4 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h4><p>一个commit应该是一个有意义的commit</p><p>有意义的定义如下： </p><ul><li>新增了一个功能或组件</li><li>修复了一个bug</li><li>解决了一个issue</li><li>重构了某个组件或文件</li><li>改善了现有代码的构建流程或风格</li></ul><p>无意义的定义如下： </p><ul><li>临时工作进度保存</li><li>误提交的 commit</li><li>commit 信息不规范或缺失</li><li>subject 无法准确描述此次 commit</li></ul><blockquote><p>注意：一个 commit 的提交应该保证代码的可运行性和完整性。</p><ul><li>可运行性：commit 提交后，运行代码不能报错</li><li>完整性：commit 提交后，当前代码中不能包含缺失的功能（如某个功能做了一半就提交）</li></ul></blockquote></li></ul><!-- #### 扩展阅读+ [虚拟DOM渲染到真实DOM的周期为多久]('')+ [这个渲染周期又是由什么来决定的]('') -->]]></content>
      
      
      <categories>
          
          <category> 效率开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端路由的区别</title>
      <link href="/post/a96b66e8.html"/>
      <url>/post/a96b66e8.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>在区别前后端路由之前，我们先了解一下路由的概念</p><blockquote><p>简单来说，路由就是 URL 到函数的映射（这个函数是广义的，可以使前端的函数，也可以是后端的函数）。对于静态资源，可以认为映射函数是对文件的读取操作。对于动态资源，则是对数据库数据的处理、读取操作。</p></blockquote><span id="more"></span><h3 id="什么是后端路由"><a href="#什么是后端路由" class="headerlink" title="什么是后端路由"></a>什么是后端路由</h3><p>在早期的 web 开发中，后端路由占主导地位。像我们常见的 php、jsp 页面，用户在地址栏中输入 URL 并回车访问的时候，客户端会把对应的路由和参数以 GET 方式对后端进行请求。后端再进行路由匹配的时候，不仅会根据 URL 来匹配，也会查看请求方式是否匹配，匹配成功，将返回对应的页面模板数据给客户端。如果路由无法匹配的对应的页面模板，则会返回 404 状态码。</p><h3 id="后端路由的优缺点"><a href="#后端路由的优缺点" class="headerlink" title="后端路由的优缺点"></a>后端路由的优缺点</h3><p>在后端路由的时代，网页中的 html 一般是由后端服务器将数据进行模板渲染再返回给前端，这种渲染方式我们称为服务器渲染。<br>服务器渲染的优势在于对 SEO 友好，因为数据由后端渲染返回，所以安全性更高。但随着 web 应用功能越来越多，需要处理更多的业务逻辑，单纯服务器渲染的弊端也慢慢显露出来：当需要返回大量数据时，页面白屏时间较长；代码维护难度大等等，这是在这种环境的要求下，前端路由慢慢的进入了人们的视线。</p><h3 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h3><p>前端路由又被称为客户端路由，因为路由的切换变化主要发生在浏览器端，路由的映射函数通常是对 DOM 进行显隐操作，当用户访问不同的页面路径时，展示不同的页面组件，比如前端流行框架 vue.js，当我们查看生产环境的 vue 项目时，会发现他的入口文件 index.html 与我们想象中的很不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;xxxx.xxx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>有使用 vue 开发过项目的同学应该都知道，vue 的单页面挂载在 app 下，而页面的渲染其实是通过 js 文件渲染出来的，这种渲染方式即我们常说的前端渲染。</p><h3 id="前端路由的优缺点"><a href="#前端路由的优缺点" class="headerlink" title="前端路由的优缺点"></a>前端路由的优缺点</h3><p>前端渲染把数据的渲染任务交给了浏览器，将大的任务颗粒化，这样一来缓解了服务器的压力，使得后端同学更专注于 api 的提供和数据库操作。另一方面，因为减少了与后端服务器的交互，所以在进行页面切换时，给用户的观感体验会更好。但同时，前端渲染也带来了一些弊端。<br>由于前后端数据分离，前端负责页面样式和数据渲染，后端只负责返回数据，导致爬虫无法爬取到有效的数据，对 SEO 不友好。</p><p><strong>在使用前端路由时，我们需要明确的是</strong></p><ul><li>地址栏输入 URL 并回车访问，依旧会向后端服务器发起 GET 请求。如果由页面中的点击或者通过前端框架的 api 进行路由跳转则不会向后端发起请求</li><li>凡是在浏览器地址栏里对 URL 进行操作都会对后端服务器发起请求</li></ul><h3 id="常见的前端路由模式"><a href="#常见的前端路由模式" class="headerlink" title="常见的前端路由模式"></a>常见的前端路由模式</h3><ul><li>hash 模式</li><li>history 模式</li></ul><p><strong>Hash 模式</strong></p><p>众所周知，hash 路由最明显的特征就是路由中的“#”符号，很特别，但也很不美观。<br>例如：<strong>http&#x2F;&#x2F;abc.com&#x2F;#&#x2F;xx</strong>，该路由中的 hash 值为“#&#x2F;xx”，我们可以通过 hashchange 事件，监听 hash 值的变化。<br>hash 模式利用的是浏览器不会将#符号后面的路径及参数对服务器发起请求，当我们在浏览器地址栏中输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//localhost/</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost/#/user/1</span></span><br></pre></td></tr></table></figure><p>这两个路由像服务端发起请求的时候，都是请求的 http&#x2F;&#x2F;localhost 页面的内容。<br>前端的路由管理通过上面提到的 hashchange 事件对 hash 值的变化进行监听，进行渲染对应的页面，这样路由的处理、切换就只是由前端来继续逻辑判断了</p><p><strong>history 模式</strong></p><p>相较于 Hash 模式，history 模式的路由最明显的变化就是去掉了其中的#符号，跟我们常见的 URL 路由没什么两样了。<br>history 模式的路由切换主要是通过 HTML5 提供的 history api 实现的。</p><p>两个操作历史栈的 api 有 history.pushState 和 history.replaceState<br><strong>history.pushState();</strong> &#x2F;&#x2F; 向历史记录中追加一条记录<br><strong>history.replaceState();</strong> &#x2F;&#x2F; 替换当前页在历史记录中的信息。</p><p>除此之外，HTML5 还在 window 对象中提供了 onpopstate 事件来监听历史栈的改变，只要历史栈有信息发生改变的话，就会触发该事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们在页面中通过 router 的 api 进行路由跳转时，调用的通常是 history.pushState()这个 api，所以又是前端进行的逻辑处理。但是如果我们在地址栏中输入地址并访问，则依旧会向后端服务器发起 GET 请求，如果后端没有对对应的路由进行配置，页面则会返回 404，这也就是生产环境页面刷新 404 的问题所在。</p><p>当然，关于 history 和 Hash 路由还有更深的内容需要探讨，等有时间另写一篇</p>]]></content>
      
      
      <categories>
          
          <category> 拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序引导用户关注公众号</title>
      <link href="/post/5c3af429.html"/>
      <url>/post/5c3af429.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在小程序使用环境中，为了给公众号引流，或者方便给用户推送消息，我们需要引导用户去关注公众号，目前接触到的大部分方案都是 用户触发客服消息 - 发送指定内容 - 收到公众号二维码 - 用户长按公众号二维码识别关注，这么一套操作实在是有些繁琐，有没有更好的方法来实现该需求呢？</p><span id="more"></span><ol><li>首先，我们在手机微信端打开公众号详情页面，并通过右上角转发按钮将公众号推荐给「文件传输助手」</li><li>在PC端点击分享的公众号卡片，我们可以看到如下页面<br><img src="https://guozhigq.github.io/img/QQ20210528-092457.png" alt="公众号卡片"></li><li>点击图中红色框中的内容，可以在电脑端查看公众号的资料页面<br><img src="https://guozhigq.github.io/img/QQ20210528-092225.png" alt="PC端公众号资料页面"></li><li>点击图中的复制按钮，就得到公众号资料页面的链接了</li><li>返回开发者工具，新建页面，并使用 webview 标签引用链接<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-view src=<span class="string">&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=xxxxxxxxxxx==&amp;scene=124#wechat_redirect&quot;</span>&gt;&lt;/web-view&gt;</span><br></pre></td></tr></table></figure></li><li>真机调试，点击进入如下界面 完结 ~<br><img src="https://guozhigq.github.io/img/QQ20210528-095934.png" alt="手机端关注"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发中的小技巧</title>
      <link href="/post/e0b676b5.html"/>
      <url>/post/e0b676b5.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在小程序开发中，经常会遇到很多奇怪的 bug，需要耗费不少的时间和精力来解决，所以在此处做一个记录，后续会不断补充。</p><span id="more"></span><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><ol><li><p>对于一般的子元素的触发事件使用 catchtap 方法即可</p></li><li><p>对于 input、video、[openType]类型的 button，我们可以同样在标签中添加 catchtap 方法，其中 catchtap 对应的方法内容为空即可，如下</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button open-type=<span class="string">&quot;share&quot;</span> catchtap=<span class="string">&quot;xxx&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="转发时多选好友"><a href="#转发时多选好友" class="headerlink" title="转发时多选好友"></a>转发时多选好友</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wx.<span class="title function_">showShareMenu</span>(&#123;</span><br><span class="line">        <span class="attr">withShareTicket</span>: <span class="literal">false</span>, <span class="comment">// 属性值为false时，开启好友分享多选功能</span></span><br><span class="line">        <span class="attr">menus</span>: [<span class="string">&#x27;shareAppMessage&#x27;</span>, <span class="string">&#x27;shareTimeline&#x27;</span>] <span class="comment">// 调用微信好友分享，朋友圈分享（朋友圈分享功能ios暂不支持 2021.02.04）</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setData-的使用事项"><a href="#setData-的使用事项" class="headerlink" title="setData 的使用事项"></a>setData 的使用事项</h4><ol><li>因为涉及到小程序渲染层与逻辑层的数据交互，所以 setData 是一个异步的过程;</li><li>直接修改 Page 实例的 this.data 是无法改变页面状态的;</li><li>如果不需要改变渲染层数据，减少使用 setData;</li><li>由于 setData 是需要两个线程的一些通信消耗，为了提高性能，每次设置的数据不应超过 1024kB;</li><li>setData 的第二个参数是一个 callback 回调，在此次 setData 对界面渲染完毕后触发; <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">text</span>: <span class="string">&quot;change text&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// setData对界面渲染完毕后触发</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="小程序页面栈最大层级为-10-层"><a href="#小程序页面栈最大层级为-10-层" class="headerlink" title="小程序页面栈最大层级为 10 层"></a>小程序页面栈最大层级为 10 层</h4><p>在类似于 <strong>列表 -&gt; 详情</strong> 业务开发中我们需要注意，在每次 wx.navigateTo()时，getCurrentPages()判断页面栈层级数，如果到达 10 层无法新增时，使用 wx.redirecTo()进行页面跳转。（将当前页面推出页面栈）</p><h4 id="小程序向上一页面传递数据"><a href="#小程序向上一页面传递数据" class="headerlink" title="小程序向上一页面传递数据"></a>小程序向上一页面传递数据</h4><p>在业务开发中，我们会遇到 <strong>A -&gt; B -&gt; A</strong> 页面回跳且需要带参数的情况，对于这种需求，我们如何来满足呢？</p><ol><li><p>在 B 页面调用后端接口，在 A 页面 onShow 方法中获取数据;</p></li><li><p>使用 globalData 全局参数。在 B 页面赋值，A 页面取值;</p></li><li><p>使用缓存 api wx.setStorageSync() wx.getStorageSync()。在 By 页面 set，A 页面 get;</p></li><li><p>使用 getCurrentPages()获取小程序页面栈，并执行 setData({})</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> pages = <span class="title function_">getCurrentPages</span>(); <span class="comment">// 获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。</span></span><br><span class="line"><span class="keyword">let</span> prevPage = pages[ pages.<span class="property">length</span> - <span class="number">2</span> ];  <span class="comment">// 获取上一页面Page() 实例</span></span><br><span class="line">prevPage.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line">    wx.<span class="title function_">navigateBack</span>(&#123;</span><br><span class="line">        <span class="attr">delta</span>: <span class="number">1</span>  <span class="comment">// 返回上一级页面。</span></span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 效率开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中的虚拟DOM</title>
      <link href="/post/1e9fca9b.html"/>
      <url>/post/1e9fca9b.html</url>
      
        <content type="html"><![CDATA[<h4 id="在了解虚拟-DOM-之前，我们先看一下浏览器的渲染流程"><a href="#在了解虚拟-DOM-之前，我们先看一下浏览器的渲染流程" class="headerlink" title="在了解虚拟 DOM 之前，我们先看一下浏览器的渲染流程"></a>在了解虚拟 DOM 之前，我们先看一下浏览器的渲染流程</h4><ol><li>解析获取到的 HTML 文档生成 DOM</li><li>解析 CSS 构成层叠样式表结构 CSSOM</li><li>将两者进行结合生成渲染树</li><li>浏览器根据渲染树上的节点信息确定其坐标值</li><li>调用每个节点的 paint 方法，将节点绘制到屏幕上 <span id="more"></span></li></ol><p><img src="https://i.loli.net/2020/12/22/2ZLbfcxYMHQCAn6.png" alt="浏览器渲染流程"></p><p>当我们使用原生 js 或者 jquery 操作 DOM 时，每对 DOM 进行一次操作，浏览器就会从头到尾执行一遍流程，当操作十分频繁时，对于浏览器的性能消耗便会变得非常严重。虚拟 DOM 就是为了解决<strong>浏览器性能问题</strong>而被设计出来的</p><h4 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h4><p>相较于 DOM 对象，原生的 JavaScript 对象处理起来速度更快，也更简单。我们也可以用 JavaScript 对象表示出 DOM 树上的结构、属性信息，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">tagName</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 1&quot;</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">tagName</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 2&quot;</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">tagName</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 3&quot;</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的 HTML 代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>既然 Javascript 对象属性可以用来描述 DOM 节点，那我们是不是可以通过一些操作将 Javascript 对象映射到真实 DOM 上<br>此时，我们边可以将虚拟 DOM 简单理解为一个 JS 对象，这个对象至少包含有标签名( tag)、属性(attrs)和子元素对象( children)三个属性。</p><h4 id="虚拟-DOM-作用是什么"><a href="#虚拟-DOM-作用是什么" class="headerlink" title="虚拟 DOM 作用是什么"></a>虚拟 DOM 作用是什么</h4><p>虚拟 DOM 的最终目的是将虚拟节点渲染到视图上，但如果直接覆盖的话，那虚拟 DOM 的存在也并没有什么意义了。为了避免不必要的 DOM 操作，虚拟 DOM 在将虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧节点进行对比，将真正需要更新内容的节点进行映射，避免操作其他无关的 DOM</p><h4 id="总结一下，虚拟-DOM-主要做了两件事"><a href="#总结一下，虚拟-DOM-主要做了两件事" class="headerlink" title="总结一下，虚拟 DOM 主要做了两件事"></a>总结一下，虚拟 DOM 主要做了两件事</h4><ol><li>通过 Javascript 对象构建虚拟节点</li><li>将本次的虚拟节点与上次的进行差异对比，再进行视图更新</li></ol><h4 id="虚拟-Dom-的优势"><a href="#虚拟-Dom-的优势" class="headerlink" title="虚拟 Dom 的优势"></a>虚拟 Dom 的优势</h4><p>「Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作&#x2F;频繁操作 DOM 的性能差」，如果 DOM 操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。</p><p>首先我们需要知道：</p><ul><li>DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）</li><li>JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，</li><li>引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。</li></ul><p>其次是 VDOM 和真实 DOM 的区别和优化：</p><ol><li>虚拟 DOM 不会立马进行排版与重绘操作</li><li>虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗</li><li>虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部</li></ol><h4 id="写到这里，不禁有了一些疑问"><a href="#写到这里，不禁有了一些疑问" class="headerlink" title="写到这里，不禁有了一些疑问"></a>写到这里，不禁有了一些疑问</h4><ul><li><a href="''">虚拟 DOM 渲染到真实 DOM 的周期为多久</a></li><li><a href="''">这个渲染周期又是由什么来决定的</a><!-- [] --><!-- 虚拟DOM之所以能够减少对浏览器性能消耗，除了用Js对象虚拟DOM之外，关键在于通过diff算法，对比虚拟DOM之间的差异，将变化的节点数据渲染到真实DOM上 --></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序使用云开发实现聊天</title>
      <link href="/post/796d8a17.html"/>
      <url>/post/796d8a17.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前做的两个项目都涉及到即时通讯功能，近期帮朋友开发小程序时也有这个需求，因为没有后端，所以决定使用云开发来实现通讯功能。 即时通讯的关键点在于即时，在之前的开发中我们可以通过websocket长连接来实现，云开发中又怎样来实现呢？</p><span id="more"></span><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><ol><li>A点击B的头像发起聊天时，根据双方id生成唯一的聊天室group_id，用于存储聊天数据。若group_id存在，则获取聊天数据</li><li>考虑到分别需要对聊天列表和聊天数据进行存储，所以我们需要建立两个集合，分别命名为msgList、msgData</li><li>发起聊天时，需要往msgList集合添加一条数据，若存在，则进行更新覆盖，用户更新聊天最后一句内容与聊天结束时间，用于展示聊天列表</li><li>进行聊天详情页，根据group_id获取对应聊天数据并进行数据渲染</li><li>聊天窗口内实时监听聊天数据，进行数据填充</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h5 id="消息发起方"><a href="#消息发起方" class="headerlink" title="消息发起方"></a>消息发起方</h5><p>发起聊天时，生成group_id并往 <strong>msgList</strong> 集合中存储一条信息，用以记录A、B双方聊天关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// group_id使用两个用户uid之和，便于对数据进行查询</span></span><br><span class="line"><span class="keyword">let</span> group_id = <span class="title class_">Number</span>(uid_a) + <span class="title class_">Number</span>(uid_b)</span><br></pre></td></tr></table></figure><p>生成的group_id，并使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.where.html">Collection.where</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.get.html">Collection.get</a> 方法从 <strong>msgList</strong> 集合中获取聊天数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _db = db.<span class="title function_">collection</span>(<span class="string">&#x27;msgList&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取聊天记录</span></span><br><span class="line">_db</span><br><span class="line">    .<span class="title function_">where</span>(&#123;<span class="attr">groupId</span>: groupId&#125;)</span><br><span class="line">    .<span class="title function_">get</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">talkData</span>: res.<span class="property">data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>发送文本消息，将数据在本地添加到talkData中，并使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.add.html">Collection.add()</a> 方法将数据添加到 <strong>msgData</strong> 集合中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chatData = &#123;</span><br><span class="line">    <span class="attr">toId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 接收人id</span></span><br><span class="line">    <span class="attr">toAvatar</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 接收人头像</span></span><br><span class="line">    <span class="attr">toName</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 接收人昵称</span></span><br><span class="line">    <span class="attr">fromId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 发送人id</span></span><br><span class="line">    <span class="attr">fromAvatar</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 发送人头像</span></span><br><span class="line">    <span class="attr">fromName</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 发送人昵称</span></span><br><span class="line">    <span class="attr">groupId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 聊天室id</span></span><br><span class="line">    <span class="attr">msgType</span>: <span class="string">&#x27;text&#x27;</span>, <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="attr">lastContent</span>: <span class="title class_">InputContent</span>, <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="attr">sendTime</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="comment">// 当前时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录聊天数据</span></span><br><span class="line">db.<span class="title function_">collection</span>(<span class="string">&#x27;msgData&#x27;</span>)</span><br><span class="line">    .<span class="title function_">add</span>(&#123;<span class="attr">data</span>: chatData&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">errMsg</span> == <span class="string">&quot;collection.add:ok&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">// 发送成功，数据放入msgData</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 发送失败的逻辑处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h5 id="消息接收方"><a href="#消息接收方" class="headerlink" title="消息接收方"></a>消息接收方</h5><p>消息接收时，关键在于使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.watch.html">Collection.watch</a> 方法 <strong>监听集合中符合查询条件的数据的更新事件</strong> ，在这里，我们结合 <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.where.html">Collection.where</a> 方法一起使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听数据变化</span></span><br><span class="line"><span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">let</span> _db = db.<span class="title function_">collection</span>(<span class="string">&#x27;msgData&#x27;</span>)</span><br><span class="line">_db </span><br><span class="line">    .<span class="title function_">where</span>(&#123;<span class="attr">toId</span>: <span class="string">&#x27;&#x27;</span>&#125;) <span class="comment">// 查询条件： 返回toId == 对方id的数据</span></span><br><span class="line">    .<span class="title function_">watch</span>(&#123;</span><br><span class="line">        <span class="attr">onChange</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> reviceMsg = res.<span class="property">docChanges</span>[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span>(reviceMsg.<span class="property">dataType</span> == <span class="string">&#x27;add&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span> talkData = that.<span class="property">data</span>.<span class="property">talkData</span></span><br><span class="line">                talkData.<span class="title function_">push</span>(reviceMsg.<span class="property">doc</span>) <span class="comment">// 将实时监听到的数据添加到本地数据中</span></span><br><span class="line">                that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                    <span class="attr">talkData</span>: talkData</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onError</span>: <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;the watch closed because of error&#x27;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端渲染如何优化</title>
      <link href="/post/f6d4c315.html"/>
      <url>/post/f6d4c315.html</url>
      
        <content type="html"><![CDATA[<p>页面性能包含了服务器请求和响应、加载、执行脚本、渲染、布局和绘制每个像素到屏幕上。这里我们只讨论[渲染、布局和绘制]这个过程。</p><p>假设我们通过请求得到了页面加载所需的资源js、css、图片等等，页面开始渲染，主要有以下几步：</p><ul><li>浏览器解析 HTML，将接收到的数据 转化为 DOM 树，解析过程中如果发现引用了外部资源则暂停解析，加载外部资源，加载完成后解析剩余HTML</li><li>解析Css，构造 CSS 模型，等到 DOM 和 CSSOM 完成之后，浏览器构造渲染树。</li><li>计算所有可见内容的样式，一旦渲染树完成布局开始，定义所有渲染树元素的位置和大小。完成之后，页面被渲染到屏幕上。这一步也称为<strong>回流重绘</strong></li></ul><p>一句话总结： 页面渲染主要分五个步骤：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。</p><h6 id="关于回流-amp-重绘的解释："><a href="#关于回流-amp-重绘的解释：" class="headerlink" title="关于回流&amp;重绘的解释："></a>关于回流&amp;重绘的解释：</h6><ul><li>回流：在页面中，当我们对元素的宽高大小进行改变时，会触发该元素以及相应的其他元素重新计算布局，这个过程就发生了回流。</li><li>重绘：重绘意味着元素只是进行了外观的变化，比如背景色、前景色，但是位置大小不变，这时候元素会重新绘制，相应的也不会对周边的元素产生影响。<br>所以我们说回流一定会发生重绘，重绘不一定导致回流，重绘的性能优于回流。</li></ul><p>既然清楚了浏览器渲染页面的大致过程，那么我们也可以做一些对应的优化</p><ul><li><p>减少频繁获取dom实例，可以使用变量临时保存，采用虚拟DOM的原因之一就是减少DOM操作<br>DOM操作会导致页面发生回流、重绘，一个元素的尺寸变化可能会导致整个页面的刷新</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span> () &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">15000</span>; count++)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">funtcion <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++&gt;)&#123;</span><br><span class="line">        content += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">innerHTML</span> += content;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>元素的批量修改，设置<code>display:none</code></p></li><li><p>大量元素的插入，使用<code>DocumentFragment</code></p></li><li><p>对于样式频繁变化的DOM，可以使用决定定位或者相对定位脱离文档流，也可以使用<code>will-change</code> 创建图层，借用 <code>GPU</code> 进行渲染，在兼容性较差的浏览上可以使用3D变形 <code>transform: translateZ(0)</code> 强制创建一个图层。</p></li><li><p>使用classList来实现对元素样式的修改，而非style，减少触发回流重绘的频次</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">box.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;size&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>避免强制更新布局</p></li></ul><p>一般的，在每次事件循环的末尾会进行一次DOM更新，这一周期大概为16ms，假如我们有以下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;big&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> width = box.<span class="property">offsetWidth</span>;</span><br></pre></td></tr></table></figure><p>在为box新增class样式后，我们马上又读取了元素的宽度，而浏览器此时还没有完成渲染，那么浏览器为了计算宽度值，就需要重新发生回流、重绘。<br>那么正确的做法是先获取宽度，再添加样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = box.<span class="property">offsetWidth</span>;</span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;big&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试官问：输入URL发生了什么</title>
      <link href="/post/a3bb328d.html"/>
      <url>/post/a3bb328d.html</url>
      
        <content type="html"><![CDATA[<p>老生常谈的面试题了</p><p>在浏览器地址栏输入URL发生了什么，主要有以下几个过程：</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><ul><li>浏览器校验输入内容是否为有效地址，否则发起搜索</li><li>进行DNS解析，以此从浏览器缓存、系统缓存、路由器缓存、ISP缓存中获取服务器的IP地址，端口号</li><li>利用IP地址和远程服务器建立TCP连接，三次握手</li><li>构建请求头信息，发起请求</li></ul><h3 id="请求发送-x2F-响应"><a href="#请求发送-x2F-响应" class="headerlink" title="请求发送&#x2F;响应"></a>请求发送&#x2F;响应</h3><ul><li>发起请求时会检查浏览器缓存，涉及<code>强缓存</code>、<code>协商缓存</code>，如果命中强缓存和协商后缓存未过期，直接从缓存中获取数据，否则获取响应数据</li><li>检查响应类型Content-Type，字节流类型调用下载管理器，否则通知浏览器进程准备渲染进程准备进行渲染</li><li>断开链接 四次挥手</li></ul><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><ul><li>获取HTML原始字节，根据文件指定编码（UTF-8）进行转换</li><li>词法分析</li><li>构建DOM   <ul><li>DOM树跟CSSOM合成生成渲染树</li><li>渲染树只包含渲染网页所需的节点</li><li>布局计算每个对象的位置跟大小</li><li>绘制，将渲染树渲染到屏幕上</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
