{"posts":[{"title":"Flutter 本地持久化与缓存","text":"Flutter 本地持久化与缓存需要使用的插件 dart:io path_provider 涉及到缓存的插件 dio_http_cache get_storage cached_network_image cookJar 3.0.1 dio_http_cache 0.3.0 缓存目录 【可使用 path_provider 提供的 getApplicationDocumentsDirectory 方法获取到】 ios 端 /Users/user/Library/Developer/CoreSimulator/Devices/A5F2542D-A814-4A70-8386-71D0094A2BFD/data/Containers/Data/Application/F9FF16B2-48DB-4003-82F1-35AAA41DC64F/Documents get_storage 2.0.3 存储登录状态、用户信息、应用主题、各配置项开关 缓存目录 【可使用 path_provider 提供的 getApplicationDocumentsDirectory 方法获取到】 ios 端 /Users/user/Library/Developer/CoreSimulator/Devices/A5F2542D-A814-4A70-8386-71D0094A2BFD/data/Containers/Data/Application/F9FF16B2-48DB-4003-82F1-35AAA41DC64F/Documents cached_network_image 3.2.3 缓存目录 ios 端 /Users/user/Library/Developer/CoreSimulator/Devices/A5F2542D-A814-4A70-8386-71D0094A2BFD/data/Containers/Data/Application/F9FF16B2-48DB-4003-82F1-35AAA41DC64F/Library/Caches/libCachedImageData 需要删除的缓存 dio_http_cache /Documents DioCacheManager(CacheConfig(baseUrl: baseUrl)).clearAll() 无效 需要手动删除 /Documents/ cached_network_image /Library/Caches/libCachedImageData","link":"/post/a690fcba.html"},{"title":"Github Action 自动构建 Flutter Android Apk","text":"前言这段时间用 Flutter 做了一个开源的项目 VVEX, 因为需要打包 apk，在此之前一直是手动 flutter build apk，再把文件上传到 release。趁着项目暂时稳定了用 Github Action 做个持续化集成，自动打包 apk。 最后完成的自动化构建脚本如下： 更新： 5月谷歌发布了Flutter stable 3.10.0 版本，可能会出现插件不兼容情况，需要将 yml 文件中flutter对应 channel 改为 any，flutter-version需要指定为某一版本，以确保打包环境正常。 为了方便阅读，部分 step 的 name 都使用了中文命名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name: build_apk# action事件触发on: push: # push tag时触发 tag: - v*# 可以有多个jobsjobs: build_apk: # 运行环境 ubuntu-latest window-latest mac-latest runs-on: ubuntu-latest # 每个jobs中可以有多个steps steps: - name: 代码迁出 uses: actions/checkout@v3 - name: 构建Java环境 uses: actions/setup-java@v3 with: distribution: &quot;zulu&quot; java-version: &quot;17&quot; token: ${{secrets.GIT_TOKEN}} - name: 检查缓存 uses: actions/cache@v2 id: cache-flutter with: path: /root/flutter-sdk # Flutter SDK 的路径 key: ${{ runner.os }}-flutter-${{ hashFiles('**/pubspec.lock') }} - name: 安装Flutter if: steps.cache-flutter.outputs.cache-hit != 'true' uses: subosito/flutter-action@v2 with: flutter-version: 3.7.7 channel: any - name: 下载项目依赖 run: flutter pub get - name: 解码生成 jks run: echo $KEYSTORE_BASE64 | base64 -di &gt; android/app/vvex.jks env: KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }} - name: flutter build apk # 对应 android/app/build.gradle signingConfigs中的配置项 run: flutter build apk --release --split-per-abi env: KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }} KEY_ALIAS: ${{ secrets.KEY_ALIAS }} KEY_PASSWORD: ${{ secrets.KEY_PASSWORD}} - name: 发布 uses: ncipollo/release-action@v1 with: artifacts: &quot;build/app/outputs/flutter-apk/app-*.apk&quot; token: ${{ secrets.GIT_TOKEN }} allowUpdates: true 在此处有两点需要特别注意一下： 无签名打包 带签名打包 无签名打包在使用 GitHub 完成自动化构建之前，一直使用的是无签名打包，很简单，不需要额外配置什么无签名打包的脚本需要去掉上面的这部分内容 1234567891011- name: 解码生成 jks run: echo $KEYSTORE_BASE64 | base64 -di &gt; android/app/vvex.jks env: KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }} - name: flutter build apk run: flutter build apk --release --split-per-abi env: KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }} KEY_ALIAS: ${{ secrets.KEY_ALIAS }} KEY_PASSWORD: ${{ secrets.KEY_PASSWORD}} 以下部分需要保留 12- name: flutter build apk run: flutter build apk --release --split-per-abi 带签名打包签名文件 xxx.js 跟 xxx.properties 文件不要提交至公共仓库主要分下面几步 生成签名 jks 文件：比如 vvex.jks 创建 key.properties 文件 修改 build.gradle 文件 Github 配置 action secrets 生成签名文件此处及以下以 VVEX 举例 Mac 环境 1234567# 移动至桌面cd desktop# 创建 jks文件夹mkdir jkscd jks# 生成jkskeytool -genkeypair -alias vvex -keyalg RSA -keysize 2048 -keypass password -keystore vvex.jks -storepass password -validity 10000 说明： -alias vvex 此处的 vvex 可以自定义修改为任意 -keystore vvex.jks 此处的 vvex 可以自定义修改为任，建议与别名相同 建议以上 vvex 为相同内容 -keypass password 此处的 password 设置密钥密码 -storepass password 此处的 password 设置密钥库密码 建议以上 password 为相同内容 vvex.jks 文件生成完成后，复制至 android/app 目录下 至此，第一步完成 创建 key.properties 文件123456789# -storepass password 处的passwordstorePassword = password# -keypass password 处的passwordkeyPassword = password# 别名keyAlias = vvex# 此处注意 直接写xxxx.jks就可以，不需要写其他路径storeFile = vvex.jks key.properties 文件生成完成后，复制至 android 目录下 至此，第一步完成 修改 build.gradle 文件android/app 目录下的 build.gradle 文件增加以下内容 12345678910111213141516171819202122232425262728293031323334// 引用 key.properties 文件def keystorePropertiesFile = rootProject.file('key.properties')def keystoreProperties = new Properties()if (keystorePropertiesFile.exists()) { keystoreProperties.load(new FileInputStream(keystorePropertiesFile))}def _storeFile = file(System.getenv(&quot;KEYSTORE&quot;) ?: keystoreProperties[&quot;storeFile&quot;] ?: &quot;vvex.jks&quot;)def _storePassword = System.getenv(&quot;KEYSTORE_PASSWORD&quot;) ?: keystoreProperties[&quot;storePassword&quot;]def _keyAlias = System.getenv(&quot;KEY_ALIAS&quot;) ?: keystoreProperties[&quot;keyAlias&quot;]def _keyPassword = System.getenv(&quot;KEY_PASSWORD&quot;) ?: keystoreProperties[&quot;keyPassword&quot;]android { ... ... signingConfigs { // 添加签名配置 release { // 配置密钥库文件的位置、别名、密码等信息 storeFile _storeFile storePassword _storePassword keyAlias _keyAlias keyPassword _keyPassword v1SigningEnabled true v2SigningEnabled true } } buildTypes { release { signingConfig signingConfigs.release } }} 其中 大写字符 KEYSTORE_PASSWORD、KEY_ALIAS、KEY_PASSWORD 在 github 设置secrets时会用到 Github 配置 action secrets 打开远程仓库的设置页面（用户名及仓库名记得替换为自己的）1https://github.com/guozhigq/flutter_test/settings/secrets/actions 点击右上方 【New repository secret】 依次创建 Actions secrets name Secret 说明 KEYSTORE_BASE64 base64 vvex.jks base64 编码 KEY_ALIAS vvex -alias vvex处的 vvex KEY_PASSWORD password -keypass password处的 password KEYSTORE_PASSWORD password -storepass password处的 password KEY_PROPERTIES base64 key.properties base64 编码 GIT_TOKEN 字符串 github 设置中生成 如何对 vvex.jks、key.properties 进行 base64 编码方便起见，将 key.properties 复制到 desktop/jks 文件夹下 123# 自动生成base64并复制到了粘贴板，直接到github复制即可base64 vvex.jks | pbcopybase64 key.properties | pbcopy 如何生成 GIT_TOKEN打开 tokens 设置页面","link":"/post/25ae93b9.html"},{"title":"JS常用的循环遍历","text":"数组遍历for 、forEach、for…of1234567891011121314151617181920212223const list = [1, 2, 3, 4, 5, 6, 7, 8, , 10, 11];for (let i = 0, len = list.length; i &lt; len; i++) { if (list[i] === 5) { break; // 1 2 3 4 // continue; // 1 2 3 4 6 7 8 undefined 10 11 } console.log(list[i]);}for (const item of list) { if (item === 5) { break; // 1 2 3 4 // continue; // 1 2 3 4 6 7 8 undefined 10 11 } console.log(item);}list.forEach((item, index, arr) =&gt; { if (item === 5) return; console.log(index); // 0 1 2 3 5 6 7 9 10 console.log(item); // 1 2 3 4 6 7 8 9 10}); 小结 这三种循环都是从左到右遍历数组; forEach 无法跳出循环；for 和 for…of 可以使用 break 或者 countinue 跳出循环或中断循环; for…of 直接访问的是实际元素。for 遍历数组索引，forEach 回调函数参数更丰富，元素、索引、原数组都可以获取; for…of 与 for 如果数组中存在空元素，同样会执行; some、every123456789const list = [ { name: &quot;头部导航&quot;, backward: false }, { name: &quot;轮播&quot;, backward: true }, { name: &quot;页脚&quot;, backward: false },];const someBackward = list.some((item) =&gt; item.backward);// someBackward: trueconst everyNewest = list.every((item) =&gt; !item.backward);// everyNewest: false 小结 二者都是用来做数组条件判断的，都是返回一个布尔值; 二者都可以被中断; some 若某一元素满足条件，返回 true，循环中断；所有元素不满足条件，返回 false; every 若有一元素不满足条件，返回 false，循环中断；所有元素满足条件，返回 true; filter、map123456789101112131415161718192021222324252627const list = [ { name: &quot;头部导航&quot;, type: &quot;nav&quot;, id: 1 }, , { name: &quot;轮播&quot;, type: &quot;content&quot;, id: 2 }, { name: &quot;页脚&quot;, type: &quot;nav&quot;, id: 3 },];const resultList = list.filter((item) =&gt; { console.log(item); return item.type === &quot;nav&quot;;});// resultList: [// { name: '头部导航', type: 'nav', id: 1 },// { name: '页脚', type: 'nav', id: 3 },// ]const newList = list.map((item) =&gt; { console.log(item); return item.id;});// newList: [1, empty, 2, 3]// list: [// { name: '头部导航', type: 'nav', id: 1 },// empty,// { name: '轮播', type: 'content', id: 2 },// { name: '页脚', type: 'nav', id: 3 },// ] 小结 二者都是生成一个新数组，都不会改变原数组（不包括遍历对象数组是，在回调函数中操作元素对象）; 二者都会跳过空元素; map 会将回调函数的返回值组成一个新数组，数组长度与原数组一致; filter 会将符合回调函数条件的元素组成一个新数组，数组长度与原数组不同; map 生成的新数组元素是可自定义; filter 生成的新数组元素不可自定义，与对应原数组元素一致; find、findIndex12345678910111213141516171819const list = [ { name: &quot;头部导航&quot;, id: 1 }, { name: &quot;轮播&quot;, id: 2 }, { name: &quot;页脚&quot;, id: 3 }, { name: &quot;页脚&quot;, id: 3 },];const result = list.find((item) =&gt; item.id === 3);// result: { name: '页脚', id: 3 }result.name = &quot;底部导航&quot;;// list: [// { name: '头部导航', id: 1 },// { name: '轮播', id: 2 },// { name: '底部导航', id: 3 },// { name: '页脚', id: 3 },// ]const index = list.findIndex((item) =&gt; item.id === 3);// index: 2list[index].name; // '底部导航'; 小结 二者都是用来查找数组元素; find 方法返回数组中满足 callback 函数的第一个元素的值。如果不存在返回 undefined; findIndex 它返回数组中找到的元素的索引，而不是其值，如果不存在返回 -1; 对象遍历for in123456789Object.prototype.fun = () =&gt; {};const obj = { 2: &quot;a&quot;, 1: &quot;b&quot; };for (const i in obj) { console.log(i, &quot;:&quot;, obj[i]);}// 1: b// 2: a// fun : () =&gt; {} Object 原型链上扩展的方法也被遍历出来for (const i in obj) { if (Object.prototype.hasOwnProperty.call(obj, i)) { console.log(i, ':', obj[i]); }}// name : a 不属于自身的属性将被 hasOwnProperty 过滤 小结 使用 for in 循环时，要注意返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例。如果只需要获取对象实例中的属性，可以使用 hasOwnProperty 进行过滤; 使用时，要使用 (const x in a) 而不是 (x in a) ，后者将会创建一个全局变量; Object.keys 用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组; 该对象可以是 数组Array、对象Object、字符串String; 当该对象为 字符串String 时，在 ES5 里，它会抛出 TypeError。在 ES2015 中，非对象的参数将被强制转换为一个对象; Object.values123var an_obj = { 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot; };console.log(Object.values(an_obj));// ['b', 'c', 'a'] 用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性值组成的数组; 当 obj 的可以值为数字时，返回顺序按照数字大小从小到大返回 同上 Object.entrise12345678910111213141516171819const obj = { foo: &quot;bar&quot;, baz: 42 };console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]// array like objectconst obj = { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; };console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]// array like object with random key orderingconst anObj = { 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot; };console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]// non-object argument will be coerced to an objectconsole.log(Object.entries(&quot;foo&quot;)); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]// iterate through key-value gracefullyconst obj = { a: 5, b: 7, c: 9 };for (const [key, value] of Object.entries(obj)) { console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;} Object.getOwnPropertyNames用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。 1234Object.prototype.fun = () =&gt; {};var obj = { a: 1, b: 2 };console.log(Object.getOwnPropertyNames(obj));// [&quot;a&quot;, &quot;b&quot;] 面试考点 for 、for in 、for…of 、 forEach 的区别 Object.keys 、 Object.values","link":"/post/5ef4056b.html"},{"title":"Tree shaking是什么？","text":"一直以来都知道在 webpack 打包优化中，有 tree shaking（别名：树摇）这一项优化，却不知道它的工作机制和原理，趁着今天复习知识的空学习一下 tree shaking 是什么？tree shaking，别名：树摇，最早是由Rollup实现。根据字面意思我们可以把它理解成一种工具，可以“摇动”我们的 JS 文件，将其中用不到的代码“摇”掉，属于性能优化的一部分。具体到实际场景中来看，我们在 webpack 项目中，会有一个入口文件，会有很多的依赖模块挂载在 index.js 下，但是我们只会用到其中的一部分，造成内存空间浪费， tree shaking 就可以将无用的模块剔除掉，实现代码体积优化的效果。 tree shaking 的工作机制因为 tree shaking 只能在静态的 modules 下工作，所以直到 ES6 的 import 语法中才可以完美使用。 tree shaking 的原理是什么？ ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码","link":"/post/f3aa05d6.html"},{"title":"Vue中的虚拟DOM","text":"在了解虚拟 DOM 之前，我们先看一下浏览器的渲染流程 解析获取到的 HTML 文档生成 DOM 解析 CSS 构成层叠样式表结构 CSSOM 将两者进行结合生成渲染树 浏览器根据渲染树上的节点信息确定其坐标值 调用每个节点的 paint 方法，将节点绘制到屏幕上 当我们使用原生 js 或者 jquery 操作 DOM 时，每对 DOM 进行一次操作，浏览器就会从头到尾执行一遍流程，当操作十分频繁时，对于浏览器的性能消耗便会变得非常严重。虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的 什么是虚拟 DOM相较于 DOM 对象，原生的 JavaScript 对象处理起来速度更快，也更简单。我们也可以用 JavaScript 对象表示出 DOM 树上的结构、属性信息，比如 1234567891011var element = { tagName: &quot;ul&quot;, props: { id: &quot;list&quot;, }, children: [ { tagName: &quot;li&quot;, props: { class: &quot;item&quot; }, children: [&quot;Item 1&quot;] }, { tagName: &quot;li&quot;, props: { class: &quot;item&quot; }, children: [&quot;Item 2&quot;] }, { tagName: &quot;li&quot;, props: { class: &quot;item&quot; }, children: [&quot;Item 3&quot;] }, ],}; 对应的 HTML 代码为 12345&lt;ul id=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然 Javascript 对象属性可以用来描述 DOM 节点，那我们是不是可以通过一些操作将 Javascript 对象映射到真实 DOM 上此时，我们边可以将虚拟 DOM 简单理解为一个 JS 对象，这个对象至少包含有标签名( tag)、属性(attrs)和子元素对象( children)三个属性。 虚拟 DOM 作用是什么虚拟 DOM 的最终目的是将虚拟节点渲染到视图上，但如果直接覆盖的话，那虚拟 DOM 的存在也并没有什么意义了。为了避免不必要的 DOM 操作，虚拟 DOM 在将虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧节点进行对比，将真正需要更新内容的节点进行映射，避免操作其他无关的 DOM 总结一下，虚拟 DOM 主要做了两件事 通过 Javascript 对象构建虚拟节点 将本次的虚拟节点与上次的进行差异对比，再进行视图更新 虚拟 Dom 的优势「Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果 DOM 操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。 首先我们需要知道： DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程） JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化， 引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。 其次是 VDOM 和真实 DOM 的区别和优化： 虚拟 DOM 不会立马进行排版与重绘操作 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部 写到这里，不禁有了一些疑问 虚拟 DOM 渲染到真实 DOM 的周期为多久 这个渲染周期又是由什么来决定的","link":"/post/1e9fca9b.html"},{"title":"webpack一二三讲","text":"webpack是什么？webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源 webpack基本功能和工作原理 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 webpack构建过程Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 webpack 热更新原理Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。 如何优化 webpack 打包速度？ 使用高版本的 webpack 和 Node.js 多进程/多实例构建：开启 parallel 参数，使用多进程压缩 css压缩：借助 optimize-css-assets-webpack-plugin 插件，压缩引擎是 cssnano 擦除无用的css：使用 PurgeCSS 来完成对无用 css 的擦除，它需要和 mini-css-extract-plugin 配合使用。 图片压缩：配置 image-webpack-loader、使用基于 Node 库的 imagemin 利用缓存提升二次构建速度： babel-loader 开启缓存 terser-webpack-plugin 开启缓存 使用 cache-loader 或者 hard-source-webpack-plugin Tree shaking (摇树) 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码 purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议) 合理使用 Ployfill 采用 polyfill-service 只给用户返回需要的polyfill 常用的Label有哪些？ raw-loader：加载文件原始内容（utf-8） file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体) url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体) source-map-loader：加载额外的 Source Map 文件，以方便断点调试 svg-inline-loader：将压缩后的 SVG 内容注入代码中 image-loader：加载并且压缩图片文件 json-loader 加载 JSON 文件（默认包含） handlebars-loader: 将 Handlebars 模版编译成函数并返回 babel-loader：把 ES6 转换成 ES5 ts-loader: 将 TypeScript 转换成 JavaScript awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader sass-loader：将SCSS/SASS代码转换成CSS css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀 eslint-loader：通过 ESLint 检查 JavaScript 代码 tslint-loader：通过 TSLint检查 TypeScript 代码 mocha-loader：加载 Mocha 测试用例的代码 coverjs-loader：计算测试的覆盖率 vue-loader：加载 Vue.js 单文件组件 i18n-loader: 国际化 cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里 常用的Plugin有哪些？ define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置) ignore-plugin：忽略部分文件 html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader) web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用 uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前) terser-webpack-plugin: 支持压缩 ES6 (Webpack4) webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度 mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin) serviceworker-webpack-plugin：为网页应用增加离线缓存功能 clean-webpack-plugin: 目录清理 ModuleConcatenationPlugin: 开启 Scope Hoisting speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时) webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块) Loader和Plugin的区别？ Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。 Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。 Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。 如何实现一个Loader？Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。 Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用 Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据 尽可能的异步化 Loader，如果计算量很小，同步也可以 Loader 是无状态的，我们不应该在 Loader 中保留状态 使用 loader-utils 和 schema-utils 为我们提供的实用工具 加载本地 Loader 方法 Npm link ResolveLoader 如何实现一个Plugin？webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。 compiler 暴露了和 Webpack 整个生命周期相关的钩子 compilation 暴露了与模块和依赖有关的粒度更小的事件钩子 插件需要在其原型上绑定apply方法，才能访问 compiler 实例 传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件 找出合适的事件点去完成想要的功能 emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机) watch-run 当依赖的文件发生变化时会触发 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住 Babel原理大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分： 解析：将代码转换成 AST 语法树 词法分析：将代码(字符串)分割为token流，即语法单元成的数组 语法分析：分析token流(上面生成的数组)并生成 AST 转换：访问 AST 的节点进行变换操作生产新的 AST 生成：以新的 AST 为基础生成代码 source Map 是什么？source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。map文件只要不打开开发者工具，浏览器是不会加载的。线上环境一般有三种处理方案： hidden-source-map：借助第三方错误监控平台 Sentry 使用nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网) 注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。 代码压缩代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。「用可接受的服务器性能压力增加来换取更好的用户体验。」源代码直接上线：虽然过程可控，但是http请求多，性能开销大。打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。","link":"/post/d9987a00.html"},{"title":"前后端路由的区别","text":"什么是路由在区别前后端路由之前，我们先了解一下路由的概念 简单来说，路由就是 URL 到函数的映射（这个函数是广义的，可以使前端的函数，也可以是后端的函数）。对于静态资源，可以认为映射函数是对文件的读取操作。对于动态资源，则是对数据库数据的处理、读取操作。 什么是后端路由在早期的 web 开发中，后端路由占主导地位。像我们常见的 php、jsp 页面，用户在地址栏中输入 URL 并回车访问的时候，客户端会把对应的路由和参数以 GET 方式对后端进行请求。后端再进行路由匹配的时候，不仅会根据 URL 来匹配，也会查看请求方式是否匹配，匹配成功，将返回对应的页面模板数据给客户端。如果路由无法匹配的对应的页面模板，则会返回 404 状态码。 后端路由的优缺点在后端路由的时代，网页中的 html 一般是由后端服务器将数据进行模板渲染再返回给前端，这种渲染方式我们称为服务器渲染。服务器渲染的优势在于对 SEO 友好，因为数据由后端渲染返回，所以安全性更高。但随着 web 应用功能越来越多，需要处理更多的业务逻辑，单纯服务器渲染的弊端也慢慢显露出来：当需要返回大量数据时，页面白屏时间较长；代码维护难度大等等，这是在这种环境的要求下，前端路由慢慢的进入了人们的视线。 什么是前端路由前端路由又被称为客户端路由，因为路由的切换变化主要发生在浏览器端，路由的映射函数通常是对 DOM 进行显隐操作，当用户访问不同的页面路径时，展示不同的页面组件，比如前端流行框架 vue.js，当我们查看生产环境的 vue 项目时，会发现他的入口文件 index.html 与我们想象中的很不一样 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;xxxx.xxx.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有使用 vue 开发过项目的同学应该都知道，vue 的单页面挂载在 app 下，而页面的渲染其实是通过 js 文件渲染出来的，这种渲染方式即我们常说的前端渲染。 前端路由的优缺点前端渲染把数据的渲染任务交给了浏览器，将大的任务颗粒化，这样一来缓解了服务器的压力，使得后端同学更专注于 api 的提供和数据库操作。另一方面，因为减少了与后端服务器的交互，所以在进行页面切换时，给用户的观感体验会更好。但同时，前端渲染也带来了一些弊端。由于前后端数据分离，前端负责页面样式和数据渲染，后端只负责返回数据，导致爬虫无法爬取到有效的数据，对 SEO 不友好。 在使用前端路由时，我们需要明确的是 地址栏输入 URL 并回车访问，依旧会向后端服务器发起 GET 请求。如果由页面中的点击或者通过前端框架的 api 进行路由跳转则不会向后端发起请求 凡是在浏览器地址栏里对 URL 进行操作都会对后端服务器发起请求 常见的前端路由模式 hash 模式 history 模式 Hash 模式 众所周知，hash 路由最明显的特征就是路由中的“#”符号，很特别，但也很不美观。例如：http//abc.com/#/xx，该路由中的 hash 值为“#/xx”，我们可以通过 hashchange 事件，监听 hash 值的变化。hash 模式利用的是浏览器不会将#符号后面的路径及参数对服务器发起请求，当我们在浏览器地址栏中输入 12http://localhost/http://localhost/#/user/1 这两个路由像服务端发起请求的时候，都是请求的 http//localhost 页面的内容。前端的路由管理通过上面提到的 hashchange 事件对 hash 值的变化进行监听，进行渲染对应的页面，这样路由的处理、切换就只是由前端来继续逻辑判断了 history 模式 相较于 Hash 模式，history 模式的路由最明显的变化就是去掉了其中的#符号，跟我们常见的 URL 路由没什么两样了。history 模式的路由切换主要是通过 HTML5 提供的 history api 实现的。 两个操作历史栈的 api 有 history.pushState 和 history.replaceStatehistory.pushState(); // 向历史记录中追加一条记录history.replaceState(); // 替换当前页在历史记录中的信息。 除此之外，HTML5 还在 window 对象中提供了 onpopstate 事件来监听历史栈的改变，只要历史栈有信息发生改变的话，就会触发该事件。 123window.addEventListener(&quot;popstate&quot;, function (e) { console.log(e);}); 当我们在页面中通过 router 的 api 进行路由跳转时，调用的通常是 history.pushState()这个 api，所以又是前端进行的逻辑处理。但是如果我们在地址栏中输入地址并访问，则依旧会向后端服务器发起 GET 请求，如果后端没有对对应的路由进行配置，页面则会返回 404，这也就是生产环境页面刷新 404 的问题所在。 当然，关于 history 和 Hash 路由还有更深的内容需要探讨，等有时间另写一篇","link":"/post/a96b66e8.html"},{"title":"前端模块化","text":"自从 JavaScript 诞生以来，人们一直将它作为一种网页脚本语言，一般只用作表单校验跟页面特效，由于被仓促的创造出来，所以它自身的各种陷阱和缺点也被编程人员所诟病。随着 Web2.0 的流行，各种前端库和框架被开发出来，随后随着更多的用户需求在前端被实现，JavaScript 也从表单校验跃迁到应用开发的级别上。在这个过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。 随着业务发展，为了能够更好的组织业务逻辑，JavaScript 有了模块化的需求。 一般的，我们在 JavaScript 中通过 script 标签引入代码的方式来实现模块化，但这样往往缺乏组织能力跟约束能力，对于开发者而言需要人为的对代码进行约束，避免变量、函数冲突等问题。 模块化的理解 什么是模块化 将代码按照功能进行封装，遵循单一职责。 模块内部数据私有, 通过向外暴露的变量、方法与外部通信。 模块化的好处 避免命名冲突(减少命名空间污染) 更好的分离, 按需加载 更高复用性 高可维护性 模块化方案 全局 function 模式，根据功能将模块封装成不同的全局函数。 nameSpace 模式，对对象进行封装。减少全局变量，解决命名冲突。 IIFE 立即执行函数，数据是私有的, 外部只能通过暴露的方法操作。 模块化规范 CommonJs概述CommonJs 规范主要用于 Node.js，每一个文件就是一个模块，有自己的作用域，每个文件中的变量、函数、类都是私有的。 特点 导出的是值的拷贝 独立作用域，不污染全局作用域 顺序加载 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了 使用 导出：使用 module.export 导出，也可以简写为 exports。CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports属性。 12345678910111213// module.export 导出function add(a, b) { return a + b;}module.export = { add: add,};// exports 导出export.add = function(a, b){ return a + b;} 导入：使用 require 同步加载模块 123// 导入var math = require(&quot;./math&quot;);math.add(2, 5); 模块重命名 12// 使用新的求和方法 newAddlet { add: newAdd } = require(&quot;./math&quot;); 加载机制CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这部分跟 ES6 模块化有所不同。 123456789// lib.jsvar counter = 3;function incCounter() { counter++;}module.exports = { counter: counter, incCounter: incCounter,}; 1234567// main.jsvar counter = require(&quot;./lib&quot;).counter;var incCounter = require(&quot;./lib&quot;).incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 在执行 incCounter 前后，lib.js 中的 counter 始终为 3，可以得知 CommonJS 输出的是值的拷贝。 ES6 模块化概述ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 特点 浏览器环境默认支持 输出的是值的引用 动态引用，不会缓存值 静态化，编译时就能确定模块间的依赖关系，以及输入输出的变量，可以 tree shaking 使用 导出：使用 export 导出 123456// math.jsvar total = 10;var add = function (a, b) { return a + b;};export { add, total }; 导入：使用 import 导入 1import { add, total } from &quot;./math&quot;; 模块重命名 1import * as newAdd from &quot;./math&quot;; 加载机制 模块加载方式取决于所处的环境，Node.js 环境中同步加载，浏览器端异步加载 AMD CMD","link":"/post/2b2f44ba.html"},{"title":"git代码规范","text":"介绍Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。但是在团队开发中，很多不规范的使用，使得 Gitf 分支混乱，代码冲突难以解决，因此我们需要对 Git 提交规范做一些了解。 在多人团队协作中，我们需要对项目代码进行共同对开发管理，在这一过程中，有很多规范需要我们严格执行： 拉取最新的 develop 分支到本地 基于最新的 develop 分支新建你自己的本地分支 修改代码后，进行 commit 和 push 切换到 develop 分支并拉取最新的 develop 分支到本地分支 切换会你自己的本地分支，然后执行命令 git rebase develop 将你的分支变更到最新的 develop 分支 执行 git push -f 强行推送你变更后的分支 在 Github 上新建 Pull Request commit规范Commit 规范采用常用的 Angular 团队所使用的规范，具体如下： 12345&lt;type&gt;&lt;scope&gt;: &lt;subject&gt;&lt;空行&gt;&lt;body&gt;&lt;空行&gt;&lt;footer&gt; type规则（必填）type 代表本次commit 的类型，有且仅有如下几种： feat - 功能性更新 fix - bug修复 style - 改变代码格式（如删除空行、格式化代码、去除不必要的分号等等） refactor - 既不是功能更新也不是 bug 修复的更改（建议对代码进行重构的时候使用） perf - 代码改变提高了性能 test - 添加测试用例或者修改测试用例 build - 由打包工具造成的改变（如gulp、webpack编译文件） chore - 既不是源码的修改，也不是测试用例的修改（修改项目相关配置时可以使用） revert - 撤销之前的提交 scope 规则（必填）scope 代表本次 commit 的影响范围，暂定规则如下： 本次 commit 修改的组件 本次 commit 修改的文件 本次 commit 修改的文件夹 注意： 选取时从上往下匹配 组件名称应使用大写字字母开头，多个单词每个单词都以大写开头 文件名应包含完整后缀，如 index.js、.eslintrc.json subject 规则（必填）用一句简短的话描述本次修改的内容，不要超过30个汉字，以动词开头 建议选用如下动词： 新增（组件、属性、事件、API） 删除 修正 修复 修改 正确示例： 新增 Collapse 组件 新增 top 属性 删除 color 属性 修复 direction 属性不生效的问题 修正 column 属性拼写 注意： subject 应该仔细斟酌，fix 和 feat 类型的 commit 的 subject 将会出现在更新日志中， 所以书写时应考虑这句话出现在更新日志中是否合适 subject 中不要包含组件名或者文件名，因为 scope 中已有对应名称 body 规则（选填）如果 subject 无法对本次 commit 进行清楚的阐释，则在 body 中进行补充说明。 建议填写以下内容： 为什么进行本次修改 本次修改了哪些内容 修改后的影响有哪些 body 需要注意换行问题，不要写在一行不换行，建议在50个字以内进行断句换行。 footer 规则（选填）footer 中只填写两种内容： 这次 commit 和某个 issue 相关联，提交后能关闭该 issue，则填写： 1close #748 或者 1fix #745 这次commit有不兼容上个版本的代码，则以 BREAKING CHANGE: 开头填写不兼容信息，如下： 1BREAKING CHANGE: Message组件top属性单位由px改为rpx Commit 示例一个完整闺房且正确的 Commit 示例如下: 12345678fix(NoticeBar)：修改top属性单位为rpxNoticeBar组件的top属性单位之前为px，会出现无法自适应的问题。更改为rpx后可对屏幕进行自适应。BREAKING CHANGE: Notice-Bar组件top属性单位由px改为rpxClose #745 推荐使用 commit 规范信息生成插件 推荐 commit 规范信息生成插件 WebStorm - Git Commit Template Vs Code - Commit Tagger 错误示例 subject 描述中出现组件名称 1feat(Button): Button 组件新增 size 属性 因type（括号中的内容）已经指定了组件，所以 subject 描述信息中无需再指明组件 单词未添加空格 1feat(Button): 新增size属性 feat、fix 类型需要慎重使用 1feat(Card): 更新 validator 校验器校验规则 因为 feat 和 fix 类型的 commit 信息会出现在 changelog 中，所以要保证这条信息是面向用户的。如上例所示，因为 validator 仅是我们自己内部使用，并不面向用户，所以用户并不关心这个校验器的新增功能。建议使用 chore 代替此处的 feat（chore 的意思是琐碎的事务） 其他事项一个commit应该是一个有意义的commit 有意义的定义如下： 新增了一个功能或组件 修复了一个bug 解决了一个issue 重构了某个组件或文件 改善了现有代码的构建流程或风格 无意义的定义如下： 临时工作进度保存 误提交的 commit commit 信息不规范或缺失 subject 无法准确描述此次 commit 注意：一个 commit 的提交应该保证代码的可运行性和完整性。 可运行性：commit 提交后，运行代码不能报错 完整性：commit 提交后，当前代码中不能包含缺失的功能（如某个功能做了一半就提交）","link":"/post/e75acacf.html"},{"title":"图床加载失败？我们来看看发生了什么","text":"最近在学习 fluuter，所以开发了一款应用，起名为：vvex。主要是 v2ex 的客户端实现，大部分数据都是通过模拟请求，解析 html 结构拿到的。 今天在手机上浏览主题时，发现在详情页会出现加载时白屏的情况，如下图。很明显可以判断是图片加载异常导致的问题。打开编辑器 🔨 ，复现一下问题，很明显我们图片资源出了点有问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283flutter: https://tutu.to/ttt_tvI99C.pngflutter: Exception: Invalid image dataflutter: Exception: Invalid image data======== Exception caught by rendering library =====================================================The following assertion was thrown during performLayout():BoxConstraints forces an infinite height.These invalid constraints were provided to RenderConstrainedBox's layout() function by the following function, which probably computed the invalid constraints in question: RenderBox.layout (package:flutter/src/rendering/box.dart:2430:11)The offending constraints were: BoxConstraints(w=357.0, h=Infinity)The relevant error-causing widget was: Stack Stack:file:///Users/user/Desktop/flutter_v2ex/lib/components/common/image_loading.dart:81:22......The following RenderObject was being processed when the exception was fired: RenderStack#e240b relayoutBoundary=up43 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE... parentData: &lt;none&gt; (can use size)... constraints: BoxConstraints(0.0&lt;=w&lt;=357.0, 0.0&lt;=h&lt;=Infinity)... size: MISSING... alignment: AlignmentDirectional.topStart... textDirection: ltr... fit: expandRenderObject: RenderStack#e240b relayoutBoundary=up43 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE parentData: &lt;none&gt; (can use size) constraints: BoxConstraints(0.0&lt;=w&lt;=357.0, 0.0&lt;=h&lt;=Infinity) size: MISSING alignment: AlignmentDirectional.topStart textDirection: ltr fit: expand... child 1: RenderConstrainedBox#b9ed3 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE... parentData: not positioned; offset=Offset(0.0, 0.0)... constraints: MISSING... size: MISSING... additionalConstraints: BoxConstraints(w=Infinity, h=60.0)... child: _RenderColoredBox#4a254 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE... parentData: &lt;none&gt;... constraints: MISSING... size: MISSING... behavior: opaque... child: RenderPositionedBox#f7ed4 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE... parentData: &lt;none&gt;... constraints: MISSING... size: MISSING... alignment: Alignment.center... textDirection: ltr... widthFactor: expand... heightFactor: expand... child: RenderParagraph#d237d NEEDS-LAYOUT NEEDS-PAINT... parentData: offset=Offset(0.0, 0.0)... constraints: MISSING... size: MISSING... textAlign: start... textDirection: ltr... softWrap: wrapping at box width... overflow: clip... locale: en_US... maxLines: unlimited... child 2: RenderParagraph#0be05 NEEDS-LAYOUT NEEDS-PAINT... parentData: right=0.0; bottom=0.0; left=0.0; offset=Offset(0.0, 0.0)... constraints: MISSING... size: MISSING... textAlign: center... textDirection: ltr... softWrap: wrapping at box width... overflow: clip... locale: en_US... maxLines: unlimited... text: TextSpan... debugLabel: (englishLike bodyMedium 2021).merge(((blackCupertino bodyMedium).apply).apply)... inherit: false... color: Color(0xff191c1b)... family: NotoSansSC... size: 14.0... weight: 400... letterSpacing: 0.3... baseline: alphabetic... height: 1.4x... leadingDistribution: even... decoration: Color(0xff191c1b) TextDecoration.none... &quot;load image failed, click to reload&quot;==================================================================================================== 尝试在浏览器中打开，发现重定向到了 https://tutu.to/show/ttt_tvI99C-png，这就值得怀疑了，是不是在 app 中使用 http get 获取图片资源时，发生了重定向直接返回了 html 结构，并非有效的 bytes 数据，导致图片加载失败呢？ 我们先尝试在postman中模拟请求，图片没有正常显示，返回了html结构 同样的，我们在 app 中直接使用 http 请求图片，跟 postman 返回了同样的 html 结构 1234567891011121314151617181920212223[log] &lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot; class=&quot;relative min-full&quot;&gt; &lt;head&gt; &lt;meta name=&quot;referrer&quot; content=&quot;strict-origin-when-cross-origin&quot; /&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt; &lt;meta name=&quot;csrf-token&quot; content=&quot;Qc2IhKwxEALVm7hdNXnLl8uaSBkpStYXnTlSvkOI&quot; /&gt; &lt;title&gt;loading&lt;/title&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0.1;url=show/ttt_tvI99C-png&quot; /&gt; &lt;script defer src=&quot;https://s.urstudio.cn/pixel/YIavbDTc6LktjXg2&quot; referrerpolicy=&quot;origin&quot; &gt;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; 于是我在浏览器中访问原主题，发现图片可以正常显示，通过查看 Dom，发现 图片链接 也相同，另外在 image 标签上有额外两个属性： 12referrerpolicy = &quot;no-referrer&quot;;rel = &quot;noreferrer&quot;; mark 此处，我们先继续往下看。 查看网络请求，发现图片资源的请求响应中并没有返回类似于 redirect 重定向的内容 复制 cURL 到 postman 模拟请求，图片可以正常返回，提取到请求头中关键字段 1'sec-fetch-dest' : image 尝试在请求头中加入这个字段，成功解决。 Sec-Fetch-DestSec-Fetch-Dest Fetch 元数据请求标头指示请求的目标，即数据的来源以及如何使用这些获取到的数据。这允许服务器根据请求是否采用了适当的使用方式来确定是否为请求提供服务。例如，具有 audio 目标的请求应请求音频数据，而不是其他类型的资源（例如，包含敏感用户信息的文档）。","link":"/post/6bb61c1a.html"},{"title":"小程序使用云开发实现聊天","text":"背景之前做的两个项目都涉及到即时通讯功能，近期帮朋友开发小程序时也有这个需求，因为没有后端，所以决定使用云开发来实现通讯功能。 即时通讯的关键点在于即时，在之前的开发中我们可以通过websocket长连接来实现，云开发中又怎样来实现呢？ 场景分析 A点击B的头像发起聊天时，根据双方id生成唯一的聊天室group_id，用于存储聊天数据。若group_id存在，则获取聊天数据 考虑到分别需要对聊天列表和聊天数据进行存储，所以我们需要建立两个集合，分别命名为msgList、msgData 发起聊天时，需要往msgList集合添加一条数据，若存在，则进行更新覆盖，用户更新聊天最后一句内容与聊天结束时间，用于展示聊天列表 进行聊天详情页，根据group_id获取对应聊天数据并进行数据渲染 聊天窗口内实时监听聊天数据，进行数据填充 具体实现消息发起方发起聊天时，生成group_id并往 msgList 集合中存储一条信息，用以记录A、B双方聊天关系。 12// group_id使用两个用户uid之和，便于对数据进行查询let group_id = Number(uid_a) + Number(uid_b) 生成的group_id，并使用 Collection.where、Collection.get 方法从 msgList 集合中获取聊天数据 12345678910let _db = db.collection('msgList')// 获取聊天记录_db .where({groupId: groupId}) .get() .then(res=&gt;{ that.setData({ talkData: res.data }) }) 发送文本消息，将数据在本地添加到talkData中，并使用 Collection.add() 方法将数据添加到 msgData 集合中 12345678910111213141516171819202122232425const chatData = { toId: '', // 接收人id toAvatar: '', // 接收人头像 toName: '', // 接收人昵称 fromId: '', // 发送人id fromAvatar: '', // 发送人头像 fromName: '', // 发送人昵称 groupId: '', // 聊天室id msgType: 'text', // 消息类型 lastContent: InputContent, // 消息内容 sendTime: new Date(), // 当前时间 ...}// 记录聊天数据db.collection('msgData') .add({data: chatData}) .then(res=&gt;{ console.log(res) if(res.errMsg == &quot;collection.add:ok&quot;){ // 发送成功，数据放入msgData }else{ // 发送失败的逻辑处理 } }) 消息接收方消息接收时，关键在于使用 Collection.watch 方法 监听集合中符合查询条件的数据的更新事件 ，在这里，我们结合 Collection.where 方法一起使用 1234567891011121314151617181920// 监听数据变化const that = thislet _db = db.collection('msgData')_db .where({toId: ''}) // 查询条件： 返回toId == 对方id的数据 .watch({ onChange: function(res) { let reviceMsg = res.docChanges[0] if(reviceMsg.dataType == 'add'){ let talkData = that.data.talkData talkData.push(reviceMsg.doc) // 将实时监听到的数据添加到本地数据中 that.setData({ talkData: talkData }) } }, onError: function(err) { console.error('the watch closed because of error', err) } })","link":"/post/796d8a17.html"},{"title":"小程序用户授权又双叒改了","text":"为了优化用户体验，小程序平台又双叒改了，此次改动又涉及到哪些api呢？ 让我们看看这次又做了哪些更改早在去年2月份，小程序社区里就发布相关公告: 《小程序登录、用户信息相关接口调整说明》大致内容总结如下： 增加通过wx.login接口获取的登录凭证可直接换取unionID: auth.code2Session说明文档 原&lt;button open-type=&quot;getUserInfo&quot;/&gt;获取用户真实个人信息的能力取消，返回匿名信息。获取openID与unionID能力不做调整。 新增getUserProfile接口，&lt;button bindtap=&quot;getUserProfile&quot;&gt;&lt;/button&gt;触发，可获取用户信息（头像、昵称、性别），用户加密数据，每次触发都会弹框。 需要注意的是：截止2021.04.09日，[wx.getUserProfile](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html) 在开发者工具调试中，基础库`2.15.0`及以下版本只返回用户信息，在基础库`2.16.0`版本增加返回`encryptedData`等用户加密数据，所以开发者一定要记得将基础库版本设置为2.16.0 getUserProfile使用123456789101112131415// wxml 方法名称随意，一定要用button按钮触发&lt;button bindtap=&quot;getUserProfile&quot;&gt;&lt;/button&gt;// jsgetUserProfile(){ wx.getUserProfile({ desc: '', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: (res) =&gt; { this.setData({ userInfo: res.userInfo // 用户信息 }) } })} 兼容实现通过上面的说明，我们可以总结以下： wx.login + wx.getUserProfile == wx.getUserInfo由于用户微信版本不一致，低版本的微信也不支持wx.getUserProfile（7.0.9以上支持），所以我们需要针对这种情况做出兼容处理，通过判断 wx.getUserProfile 是否存在来决定采用哪种授权方案wxml代码如下 123456789101112&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;block wx:if=&quot;{{!hasUserInfo}}&quot;&gt; &lt;button wx:if=&quot;{{canIUseGetUserProfile}}&quot; bindtap=&quot;getUserProfile&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt;&lt;/view&gt; js代码如下 123456789101112131415161718192021222324252627282930313233343536Page({ data: { userInfo: {}, hasUserInfo: false, canIUseGetUserProfile: false, }, onLoad() { if (wx.getUserProfile) { this.setData({ canIUseGetUserProfile: true }) } }, getUserProfile(e) { // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认 // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗 wx.getUserProfile({ desc: '用于完善会员资料', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: (res) =&gt; { console.log(res) this.setData({ userInfo: res.userInfo, hasUserInfo: true }) } }) }, getUserInfo(e) { // 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息 this.setData({ userInfo: e.detail.userInfo, hasUserInfo: true }) },}) 对于用户头像、昵称等信息，可以按照下列方式进行处理 前端调用wx.getUserProfile后，将用户信息缓存在本地 前端调用wx.getUserProfile后，将用户信息发送给后端，与用户信息绑定在一起注：在此处推荐方法2，这样一来用户在pc端打开小程序也可以直接从后端获取头像，而不需要再次授权 吐槽 按照目前官方的文档说明和公告，wx.getUserProfile和wx.getUserInfo的区别只在于弹框触发的频率，前者触发的时候每次都弹框，后者只会弹框一次，实在是不理解为什么要新增一个API而不是对现有的进行修改 官方说明在4.13号及之后提交的正式版小程序中，将支持wx.getUserProfile，wx.getUserInfo将返回匿名用户信息，但是，在4.2/3号，很多线上的小程序wx.getUserInfo也返回了匿名消息，导致社区很多开发者反馈线上小程序无法获取用户信息。","link":"/post/80bad882.html"},{"title":"微信小程序引导用户关注公众号","text":"背景在小程序使用环境中，为了给公众号引流，或者方便给用户推送消息，我们需要引导用户去关注公众号，目前接触到的大部分方案都是 用户触发客服消息 - 发送指定内容 - 收到公众号二维码 - 用户长按公众号二维码识别关注，这么一套操作实在是有些繁琐，有没有更好的方法来实现该需求呢？ 首先，我们在手机微信端打开公众号详情页面，并通过右上角转发按钮将公众号推荐给「文件传输助手」 在PC端点击分享的公众号卡片，我们可以看到如下页面 点击图中红色框中的内容，可以在电脑端查看公众号的资料页面 点击图中的复制按钮，就得到公众号资料页面的链接了 返回开发者工具，新建页面，并使用 webview 标签引用链接1&lt;web-view src=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=xxxxxxxxxxx==&amp;scene=124#wechat_redirect&quot;&gt;&lt;/web-view&gt; 真机调试，点击进入如下界面 完结 ~","link":"/post/5c3af429.html"},{"title":"微信小程序开发中的小技巧","text":"背景在小程序开发中，经常会遇到很多奇怪的 bug，需要耗费不少的时间和精力来解决，所以在此处做一个记录，后续会不断补充。 阻止事件冒泡 对于一般的子元素的触发事件使用 catchtap 方法即可 对于 input、video、[openType]类型的 button，我们可以同样在标签中添加 catchtap 方法，其中 catchtap 对应的方法内容为空即可，如下 12345&lt;button open-type=&quot;share&quot; catchtap=&quot;xxx&quot;&gt;&lt;/button&gt;xxx(){} 转发时多选好友123456onLoad: function() { wx.showShareMenu({ withShareTicket: false, // 属性值为false时，开启好友分享多选功能 menus: ['shareAppMessage', 'shareTimeline'] // 调用微信好友分享，朋友圈分享（朋友圈分享功能ios暂不支持 2021.02.04） });} setData 的使用事项 因为涉及到小程序渲染层与逻辑层的数据交互，所以 setData 是一个异步的过程; 直接修改 Page 实例的 this.data 是无法改变页面状态的; 如果不需要改变渲染层数据，减少使用 setData; 由于 setData 是需要两个线程的一些通信消耗，为了提高性能，每次设置的数据不应超过 1024kB; setData 的第二个参数是一个 callback 回调，在此次 setData 对界面渲染完毕后触发; 123456789101112Page({ onLoad: function () { this.setData( { text: &quot;change text&quot;, }, function () { // setData对界面渲染完毕后触发 } ); },}); 小程序页面栈最大层级为 10 层在类似于 列表 -&gt; 详情 业务开发中我们需要注意，在每次 wx.navigateTo()时，getCurrentPages()判断页面栈层级数，如果到达 10 层无法新增时，使用 wx.redirecTo()进行页面跳转。（将当前页面推出页面栈） 小程序向上一页面传递数据在业务开发中，我们会遇到 A -&gt; B -&gt; A 页面回跳且需要带参数的情况，对于这种需求，我们如何来满足呢？ 在 B 页面调用后端接口，在 A 页面 onShow 方法中获取数据; 使用 globalData 全局参数。在 B 页面赋值，A 页面取值; 使用缓存 api wx.setStorageSync() wx.getStorageSync()。在 By 页面 set，A 页面 get; 使用 getCurrentPages()获取小程序页面栈，并执行 setData({}) 1234567891011let pages = getCurrentPages(); // 获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。let prevPage = pages[ pages.length - 2 ]; // 获取上一页面Page() 实例prevPage.setData({ ...}, wx.navigateBack({ delta: 1 // 返回上一级页面。 }))","link":"/post/e0b676b5.html"}],"tags":[{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"工程化","slug":"工程化","link":"/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"效率开发","slug":"效率开发","link":"/categories/%E6%95%88%E7%8E%87%E5%BC%80%E5%8F%91/"},{"name":"拓展","slug":"拓展","link":"/categories/%E6%8B%93%E5%B1%95/"}],"pages":[{"title":"","text":"个人信息 郭志斌/男/1995 本科/山西农业大学信息学院 工作年限：3 年 联系方式： 13734077064 邮箱：guozhigq@outlook.com 技术博客：https://guozhigq.github.io Github：https://github.com/guozhigq 期望职位：前端开发工程师 技能清单 熟练使用 HTML5、CSS3、jQuery、ES6 语法进行开发 对于 ES6 闭包、原型链、this 指向等特性有自己的理解 熟练掌握小程序开发，熟练使用小程序 api 熟悉微信公众号 jssdk 场景开发，有独立解决 bug 能力 熟练使用 vue 全家桶（vue-cli、vue-router、vuex） 熟练使用 webpack 构建工具，了解 CommonJS、 CMD、AMD 的模块化规范 熟悉 gitflow 开发流程 了解 Promise A+规范 有 nuxt.js 使用经验，了解 vite 工作经历你我校科技有限公司 （ 2020.03 ~ 2021.05 ）你我校 微信小程序项目项目描述：类似于大众点评的教育聚合平台，借助微信-小程序平台增加 c 端机构的曝光量，减少获客成本。 为 B 端教育机构提供课程、教师、优惠券、订单查询、课程咨询等功能 为 C 端用户提供商户信息、课程点评及消费优惠等信息服务 用户发布视频、帖子功能，增加用户留存率 个人职责： 完成了首页评论瀑布流功能及长列表优化 对功能进行抽象化，提高代码复用率 完成类抖音视频流功能开发，优化视频组件在 ios 端的卡顿问题 封装小程序分享方法，进行统一配置 推动开发流程规范化 你我校官网为了让 B、C 端用户对你我校的产品及企业信息有更深入的了解，完成了你我校官网的搭建。为了解决首屏白屏问题以及更好的实现 SEO，通过 nuxt.js 框架实现服务端渲染（SSR） 清华美院 h5 项目项目描述：帮助商户开发的公众号 H5 页面，旨在帮助用户更方便的线上购课，免去繁琐的线下报名交易环节，优化交易流程，提高用户转化率及复购率。个人职责： 利用 vue-router 实现全局拦截公众号授权 微信好友、朋友圈分销体系 朔宇科技有限公司 （ 2019.07 ~ 2020.03 ）惠团学 微信小程序项目项目描述：独立完成微信小程序以及后台管理系统。该小程序为先生授课类小程序，包括分类筛选、搜索、购买、红包充值提现、咨询聊天、海报分享等功能。技术栈：原生小程序、Vue.js；UI 框架：vantUI、elementUI个人职责： 开发页面 60+，服用公共组件 10+，提高代码可复用性； 开发课程咨询功能，消息未读计数； 提供课程拼团功能，拼团人数 2-5 人，时间限制 24 小时； 使用 canvas 绘制分享海报。包括学校、课程信息； 后台管理系统实现视频分片上传功能； 这个项目中，我遇到的困难有： 小程序顶部导航栏需要实现分栏效果，手写自定义组件，兼容市面上的安卓、IOS 设备 视频上传时截取第一帧作为视频封面，使用 canvas 的 drawImage 方法进行图片绘制； 近邻宝 - 校园跑腿 H5 项目独立完成快递代取 H5 项目以及后台管理系统的前端部分，提供校园或社区快递代取类跑腿服务，包括订单创建、支付打赏，单用户多身份功能。技术栈：Vue.js ；UI 框架：weUI 充分考虑 H5 页面的跳转逻辑，对支付功能进行优化； 页面添加下拉刷新、上拉加载分页功能； 列表页面使用 keep-alive 缓存处理，避免重复加载； 使用双令牌机制无感知刷新 token，解决 H5 页面安全性问题； 这个项目中，我遇到的困难有 微信 H5 页面分享功能在 IOS 端调用失败，采用 window.location.href 路由跳转解决； 列表页面缓存处理后，从上级页面进入不刷新，采用 exclude 属性将组件设置为不缓存状态； 这个项目中，我最自豪的技术细节是优化用户订单支付逻辑，考虑并完善了多种支付情况，提升了用户体验。 个人开源项目小程序聊天 Demo使用原生小程序开发的聊天 Demo，基本实现了发送文本 、文本+emoji 、图片、语音、文件功能，开箱即用。 大声朗读微软 Edge 浏览器大声朗读功能的代码实现，可以实现语音倍速，变化语调功能，支持多国语言。具体功能项视系统环境而定，已经部署到 Github Page，点我在线预览。","link":"/about/index.html"}]}